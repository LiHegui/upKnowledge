import{_ as s,e as n,f as l,o as a}from"./app-BeRZjn83.js";const t="/upKnowledge/assets/image-CUhasbhW.png",i={};function o(d,e){return a(),n("div",null,e[0]||(e[0]=[l(`<h2 id="http和https" tabindex="-1"><a class="header-anchor" href="#http和https"><span>http和https</span></a></h2><p>HTTP是传文本传输协议，是实现网络通信的一种规范。 HTTP常用于在Web浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密。 特点如下：</p><ul><li>支持客户端/服务器模式</li><li>简单快速 客户端向服务器请求服务时，只需传送请求方法和路径。由于http协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li>灵活 HTTP允许传输任意类型的数据对象。正在传输的又Content-Type标记。</li><li>无连接 每次连接只处理一次请求。服务器处理完客户请求，并收到客户的应答后，即断开连接。采用这种方式可以节约传输时间。</li><li>无状态 每个请求都是独立的，服务器不会记录之前的请求，所以对于每次请求都会返回相同的结果。 HTTPS HTTP是以明文的方式进行传送，这样是并不安全的。而HTTPS出现正是为了解决HTTP不安全的特性。 多的这一层是SSL/TCL协议，通过SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。 SSL协议位于TCP/IP</li></ul><h2 id="https的加密流程" tabindex="-1"><a class="header-anchor" href="#https的加密流程"><span>https的加密流程</span></a></h2><p>HTTPS（HTTP Secure）是在HTTP协议基础上添加了安全性功能的协议，使用加密来保护数据的传输。以下是HTTPS的加密流程：</p><ul><li>客户端发起连接请求：客户端（例如浏览器）向服务器发送一个连接请求，指示其希望建立一个安全的HTTPS连接。</li><li>服务器发送证书：服务器收到客户端的请求后，会将自己的数字证书发送给客户端。数字证书包含了服务器的公钥、证书有效期、证书颁发机构等信息。</li><li>客户端验证证书：客户端接收到服务器的证书后，会验证证书的有效性。这包括检查证书的签名是否有效、证书是否过期、证书颁发机构是否受信任等。</li><li>客户端生成随机密钥：如果证书验证成功，客户端会生成一个随机的对称密钥（即会话密钥），用于后续的对称加密。</li><li>使用服务器的公钥加密会话密钥：客户端使用服务器的公钥对生成的会话密钥进行加密，并将加密后的会话密钥发送给服务器。</li><li>服务器使用私钥解密会话密钥：服务器收到客户端发送的加密会话密钥后，使用自己的私钥进行解密，得到会话密钥。</li><li>加密通信：客户端和服务器现在都拥有相同的会话密钥。双方使用该会话密钥进行对称加密，加密和解密传输的数据。 通过这个过程，HTTPS实现了安全的通信。客户端和服务器之间的数据传输是经过加密的，确保了数据的机密性和完整性，同时防止了中间人攻击和窃听。</li></ul><h2 id="如何理解osi七层模型" tabindex="-1"><a class="header-anchor" href="#如何理解osi七层模型"><span>如何理解OSI七层模型?</span></a></h2><p>每一层实现各自的功能和协议，并完成与相邻的接口通信。</p><ul><li><p>应用层 DNS,HTTP，HTTPS</p></li><li><p>表示层</p></li><li><p>会话层</p></li><li><p>传输层 传输层的主要任务是为了两台主进程之间的通信提供服务，处理数据包错误、数据包次序，以及其它一些关键传输的问题。 TCP和UDP</p></li><li><p>网络层</p></li><li><p>数据链路层</p></li><li><p>物理层</p></li></ul><h2 id="三次握手和四次挥手" tabindex="-1"><a class="header-anchor" href="#三次握手和四次挥手"><span>三次握手和四次挥手</span></a></h2><p>TCP（传输控制协议）是一种面向连接的、可靠的传输层协议。在建立连接和断开连接时，TCP 使用<strong>三次握手</strong>和<strong>四次挥手</strong>的机制来确保数据的可靠传输。以下是它们的简要说明：</p><hr><h3 id="tcp-三次握手-建立连接" tabindex="-1"><a class="header-anchor" href="#tcp-三次握手-建立连接"><span><strong>TCP 三次握手（建立连接）</strong></span></a></h3><p>三次握手用于在客户端和服务器之间建立 TCP 连接。目的是确保双方都能发送和接收数据。</p><ol><li><p><strong>第一次握手（SYN）</strong>：</p><ul><li>客户端向服务器发送一个 <code>SYN</code>（同步）报文，其中包含一个随机生成的初始序列号（<code>seq = x</code>）。</li><li>客户端进入 <code>SYN_SENT</code> 状态。</li></ul></li><li><p><strong>第二次握手（SYN + ACK）</strong>：</p><ul><li>服务器收到 <code>SYN</code> 报文后，向客户端发送一个 <code>SYN + ACK</code>（同步 + 确认）报文。 <ul><li><code>ACK</code> 报文的确认号为 <code>x + 1</code>（表示期望收到客户端的下一个序列号）。</li><li>服务器也会生成一个随机序列号 <code>seq = y</code>。</li></ul></li><li>服务器进入 <code>SYN_RECEIVED</code> 状态。</li></ul></li><li><p><strong>第三次握手（ACK）</strong>：</p><ul><li>客户端收到 <code>SYN + ACK</code> 报文后，向服务器发送一个 <code>ACK</code>（确认）报文，确认号为 <code>y + 1</code>。</li><li>客户端和服务器都进入 <code>ESTABLISHED</code> 状态，连接建立成功。</li></ul></li></ol><p><strong>总结</strong>：</p><ul><li>三次握手的目的是确保双方都能发送和接收数据。</li><li>通过交换初始序列号，双方可以确保数据的有序性和完整性。</li></ul><hr><h3 id="tcp-四次挥手-断开连接" tabindex="-1"><a class="header-anchor" href="#tcp-四次挥手-断开连接"><span><strong>TCP 四次挥手（断开连接）</strong></span></a></h3><p>四次挥手用于在客户端和服务器之间断开 TCP 连接。目的是确保双方都能安全地关闭连接。</p><ol><li><p><strong>第一次挥手（FIN）</strong>：</p><ul><li>客户端向服务器发送一个 <code>FIN</code>（结束）报文，表示客户端没有数据要发送了。</li><li>客户端进入 <code>FIN_WAIT_1</code> 状态。</li></ul></li><li><p><strong>第二次挥手（ACK）</strong>：</p><ul><li>服务器收到 <code>FIN</code> 报文后，向客户端发送一个 <code>ACK</code> 报文，确认收到 <code>FIN</code>。</li><li>服务器进入 <code>CLOSE_WAIT</code> 状态，客户端进入 <code>FIN_WAIT_2</code> 状态。</li><li>此时，服务器可能还有未发送完的数据。</li></ul></li><li><p><strong>第三次挥手（FIN）</strong>：</p><ul><li>当服务器完成数据发送后，向客户端发送一个 <code>FIN</code> 报文，表示服务器也没有数据要发送了。</li><li>服务器进入 <code>LAST_ACK</code> 状态。</li></ul></li><li><p><strong>第四次挥手（ACK）</strong>：</p><ul><li>客户端收到 <code>FIN</code> 报文后，向服务器发送一个 <code>ACK</code> 报文，确认收到 <code>FIN</code>。</li><li>客户端进入 <code>TIME_WAIT</code> 状态，等待一段时间（2MSL，Maximum Segment Lifetime）以确保服务器收到 <code>ACK</code>。</li><li>服务器收到 <code>ACK</code> 后，关闭连接，进入 <code>CLOSED</code> 状态。</li><li>客户端在 <code>TIME_WAIT</code> 结束后，也关闭连接，进入 <code>CLOSED</code> 状态。</li></ul></li></ol><p><strong>总结</strong>：</p><ul><li>四次挥手的目的是确保双方都能安全地关闭连接。</li><li>通过 <code>FIN</code> 和 <code>ACK</code> 的交换，确保双方都完成了数据的发送和接收。</li></ul><hr><h3 id="为什么需要三次握手和四次挥手" tabindex="-1"><a class="header-anchor" href="#为什么需要三次握手和四次挥手"><span><strong>为什么需要三次握手和四次挥手？</strong></span></a></h3><ol><li><p><strong>三次握手</strong>：</p><ul><li>确保双方都能发送和接收数据。</li><li>防止已失效的连接请求报文突然传送到服务器，导致错误。</li></ul></li><li><p><strong>四次挥手</strong>：</p><ul><li>确保双方都能安全地关闭连接。</li><li>服务器可能需要时间处理未发送完的数据，因此需要分两次发送 <code>ACK</code> 和 <code>FIN</code>。</li></ul></li></ol><hr><h3 id="示意图" tabindex="-1"><a class="header-anchor" href="#示意图"><span><strong>示意图</strong></span></a></h3><h4 id="三次握手" tabindex="-1"><a class="header-anchor" href="#三次握手"><span>三次握手：</span></a></h4><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">客户端 -&gt; SYN -&gt; 服务器</span>
<span class="line">客户端 &lt;- SYN + ACK &lt;- 服务器</span>
<span class="line">客户端 -&gt; ACK -&gt; 服务器</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="四次挥手" tabindex="-1"><a class="header-anchor" href="#四次挥手"><span>四次挥手：</span></a></h4><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">客户端 -&gt; FIN -&gt; 服务器</span>
<span class="line">客户端 &lt;- ACK &lt;- 服务器</span>
<span class="line">客户端 &lt;- FIN &lt;- 服务器</span>
<span class="line">客户端 -&gt; ACK -&gt; 服务器</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>希望这个回答对你有帮助！如果还有其他问题，欢迎继续提问！</p><h2 id="tcp协议和udp协议的区别" tabindex="-1"><a class="header-anchor" href="#tcp协议和udp协议的区别"><span>TCP协议和UDP协议的区别</span></a></h2><ul><li>他们都位于osi七层模型的传输层</li><li>主要区别</li></ul><ol><li>可靠性：tcp是一种可靠的协议，它提供了数据之间的可靠传输和错误检验机制。它可以确认、重传和流控制等机制来确保数据的完整性和数序性。udp是一种不可靠的协议，它不提供数据的可靠性传输保证，每个数据报都是独立的实体，可能丢失、重复或者乱序。</li><li>连接性：tcp是一种面向连接的协议，他在通信之前需要通过三次握手来确保通信双方之间的连接建立。udp是一种面向无连接的协议，它不需要建立连接，发送方可以直接将数据报发送到目标地址</li><li>传输效率：因为tcp提供了可靠性和复杂的控制机制，所以它的传输效率相对较低。而udp是一种轻量级的协议，没复杂的控制机制，所以传输效率相对较快</li><li>tcp是面向字节流的，将应用层的报文看成一串串的无结构的字节流，分解到多个tcp报文中传输后，在目标站重新装配。udp协议面向报文，不拆分报文，只保留边界，一个个发送报文，接收方去除报文首部后，原封不动的把报文交给上层。</li><li>tcp应用于对数据完整性和可靠性要求高的应用场景，如网页浏览，文件传输，电子邮件等。udp适用于实时性要求高的、对数据可靠性要求较低的场景，如音视频播放、实时游戏、流媒体等。</li></ol><h2 id="说说对websocket的理解-应用场景" tabindex="-1"><a class="header-anchor" href="#说说对websocket的理解-应用场景"><span>说说对WebSocket的理解？应用场景？</span></a></h2><p>WebSocket是一种网络传输协议。 可在单个TCP连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通讯。 客户端和服务器之间只需要一次握手，两者之间就可以创建持久性的连接，数据双向传输</p><ul><li><p>全双工 允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。</p></li><li><p>二进制帧</p></li><li><p>协议名 ws和wss分别代表明文和密文的websocket协议，默认端口使用80或443</p></li><li><p>握手</p></li><li><p>优点</p><ul><li>更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少</li></ul></li></ul><h2 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景</span></a></h2><p>一些需要实时更新的场景</p><h2 id="说说地址栏输入-url-敲下回车后发生了什么" tabindex="-1"><a class="header-anchor" href="#说说地址栏输入-url-敲下回车后发生了什么"><span>说说地址栏输入 URL 敲下回车后发生了什么?</span></a></h2><ul><li>URL解析：首先判断你输入的是一个合法的URL 还是一个待搜索的关键词，并且根据你输入的内容进行对应操作</li><li>DNS 查询：见下文</li><li>TCP 连接：基于url解析出来的协议来和服务器建立连接</li><li>HTTP 请求：一旦与服务器建立连接，浏览器会发送一个HTTP请求，其中包含请求的方法（GET、POST等）、目标URL、请求头部和请求体等信息</li><li>处理请求：服务器接收到浏览器发送的HTTP请求后，会根据请求中的信息进行处理。它会解析URL、读取请求头部和请求体，并执行相应的逻辑来生成响应</li><li>响应请求：服务器根据请求的处理结果生成一个HTTP响应，包括响应状态码、响应头部和响应体等信息。响应的内容可能是HTML页面、图像、文本文件或其他数据</li><li>接受请求：浏览器接收到服务器发送的HTTP响应后，会读取响应头部和响应体等信息</li><li>页面渲染：如果响应是一个HTML页面，浏览器会解析HTML代码，并根据其中的CSS和JavaScript等资源进行页面的渲染和布局</li></ul><h2 id="dns解析过程" tabindex="-1"><a class="header-anchor" href="#dns解析过程"><span>DNS解析过程</span></a></h2><p>什么是dns：域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器。简单来讲，DNS相当于一个翻译官，负责将域名翻译成ip地址 IP 地址：一长串能够唯一地标记网络上的计算机的数字 域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对网站的定位标识 解析域名的过程如下：</p><ul><li>首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</li><li>若没有命中，则继续搜索操作系统的 DNS 缓存</li><li>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</li><li>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询 <ul><li>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</li><li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li><li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li></ul></li><li>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</li><li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起</li><li>至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起 <img src="`+t+`" alt="Alt text"></li></ul><h2 id="http发送请求和dns发送一个请求的区别以及哪个更快" tabindex="-1"><a class="header-anchor" href="#http发送请求和dns发送一个请求的区别以及哪个更快"><span>http发送请求和dns发送一个请求的区别以及哪个更快</span></a></h2><p>HTTP（Hypertext Transfer Protocol）和DNS（Domain Name System）是在互联网通信中扮演不同角色的两个协议，它们的作用和性质有所不同。下面是它们在发送请求方面的区别：</p><ul><li>TTP请求：HTTP是用于在客户端和服务器之间传输超文本数据的协议。当客户端需要获取某个资源（如网页、图片、视频等）时，会通过HTTP协议发送一个HTTP请求给服务器，请求的内容包括请求方式（如GET、POST）、请求路径、请求头和请求体等。服务器接收到请求后，根据请求的路径和其他信息，处理请求并返回相应的资源。</li><li>DNS请求：DNS是用于将域名解析为对应IP地址的协议。当客户端需要访问某个域名的网站时，它需要先将域名转换为IP地址，以便建立与服务器的连接。客户端会发送一个DNS查询请求给DNS服务器，请求的内容包括要解析的域名。DNS服务器接收到请求后，会递归地查询和解析域名，并返回对应的IP地址给客户端。 在请求的速度方面，DNS请求通常比HTTP请求快速。这是因为DNS请求通常只涉及域名解析的过程，而该过程通常是在本地操作系统或本地DNS缓存中完成的，而不需要通过网络发送到远程服务器。因此，DNS解析的速度主要取决于本地缓存和网络环境的响应速度。</li></ul><hr><p>相比之下，HTTP请求涉及到与服务器的通信，需要经过网络传输数据。HTTP请求的速度受到多个因素的影响，包括网络延迟、服务器响应时间、带宽限制等。因此，HTTP请求的速度通常比DNS请求慢一些。</p><p>需要注意的是，HTTP和DNS是在不同的层面上进行通信的协议，它们的目的和功能不同。HTTP用于传输数据，实现客户端和服务器之间的通信；而DNS用于域名解析，将域名映射为IP地址。它们在互联网通信中发挥着各自重要的作用，无法直接比较哪个更快，因为它们的性质和功能不同。</p><h2 id="常见的http请求头" tabindex="-1"><a class="header-anchor" href="#常见的http请求头"><span>常见的HTTP请求头</span></a></h2><ul><li><p>accept 浏览器可接受的MIME类型，如application/json、text/plain等</p></li><li><p>Cookie</p></li><li><p>Host 初始URL中的主机和端口</p></li></ul><h2 id="http缓存-强缓存、协商缓存" tabindex="-1"><a class="header-anchor" href="#http缓存-强缓存、协商缓存"><span><span style="color:red;font-weight:700;">HTTP缓存（强缓存、协商缓存）</span></span></a></h2><p>HTTP 缓存分为<strong>强缓存</strong>和<strong>协商缓存</strong>两种机制，它们共同作用以减少不必要的网络请求，提升性能。以下是它们的详细说明：</p><hr><p><strong>1. 强缓存</strong> 强缓存是指客户端直接从本地缓存中获取资源，而不向服务器发送请求。强缓存通过响应头中的 <code>Cache-Control</code> 和 <code>Expires</code> 字段来控制。</p><p><strong>实现强缓存的响应头字段</strong></p><ul><li><p><strong><code>Cache-Control</code></strong>：</p><ul><li><code>max-age=&lt;seconds&gt;</code>：资源在缓存中的最大存活时间（相对于请求时间）。</li><li><code>no-cache</code>：不使用强缓存，每次请求都需验证资源是否更新。</li><li><code>no-store</code>：禁止缓存资源。</li><li><code>public</code>：资源可以被任何缓存（如浏览器、代理服务器）缓存。</li><li><code>private</code>：资源只能被客户端缓存，不能被代理服务器缓存。</li></ul><p>示例：</p><div class="language-http line-numbers-mode" data-highlighter="prismjs" data-ext="http" data-title="http"><pre><code><span class="line"><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">max-age=3600, public</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong><code>Expires</code></strong>：</p><ul><li>指定资源的过期时间（绝对时间），是一个 HTTP/1.0 的字段。</li><li>示例：<div class="language-http line-numbers-mode" data-highlighter="prismjs" data-ext="http" data-title="http"><pre><code><span class="line"><span class="token header"><span class="token header-name keyword">Expires</span><span class="token punctuation">:</span> <span class="token header-value">Wed, 21 Oct 2023 07:28:00 GMT</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li></ul><p><strong>强缓存的工作流程</strong></p><ol><li>客户端首次请求资源，服务器返回资源并设置 <code>Cache-Control</code> 或 <code>Expires</code>。</li><li>客户端再次请求时，先检查缓存是否过期： <ul><li>如果未过期（<code>max-age</code> 或 <code>Expires</code> 有效），直接从缓存中读取资源，<strong>不会向服务器发送请求</strong>。</li><li>如果已过期，则进入协商缓存流程。</li></ul></li></ol><p><strong>强缓存的命中与未命中</strong></p><ul><li><strong>命中</strong>：状态码为 <code>200 (from disk cache)</code> 或 <code>200 (from memory cache)</code>。</li><li><strong>未命中</strong>：缓存失效，进入协商缓存。</li></ul><hr><p><strong>2. 协商缓存</strong> 协商缓存是指客户端向服务器发送请求，验证本地缓存是否仍然有效。如果有效，服务器返回 <code>304 Not Modified</code>，客户端使用本地缓存；如果无效，服务器返回新的资源。</p><p><strong>实现协商缓存的响应头字段</strong></p><ul><li><p><strong><code>Last-Modified</code> 和 <code>If-Modified-Since</code></strong>：</p><ul><li><code>Last-Modified</code>：服务器返回资源时，携带资源的最后修改时间。</li><li><code>If-Modified-Since</code>：客户端再次请求时，将该时间发送给服务器，服务器判断资源是否修改。</li><li>示例：<div class="language-http line-numbers-mode" data-highlighter="prismjs" data-ext="http" data-title="http"><pre><code><span class="line"><span class="token header"><span class="token header-name keyword">Last-Modified</span><span class="token punctuation">:</span> <span class="token header-value">Wed, 21 Oct 2023 07:28:00 GMT</span></span></span>
<span class="line"><span class="token header"><span class="token header-name keyword">If-Modified-Since</span><span class="token punctuation">:</span> <span class="token header-value">Wed, 21 Oct 2023 07:28:00 GMT</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong><code>ETag</code> 和 <code>If-None-Match</code></strong>：</p><ul><li><code>ETag</code>：服务器返回资源时，携带资源的唯一标识（通常是哈希值）。</li><li><code>If-None-Match</code>：客户端再次请求时，将该标识发送给服务器，服务器判断资源是否修改。</li><li>示例：<div class="language-http line-numbers-mode" data-highlighter="prismjs" data-ext="http" data-title="http"><pre><code><span class="line"><span class="token header"><span class="token header-name keyword">ETag</span><span class="token punctuation">:</span> <span class="token header-value">&quot;123456&quot;</span></span></span>
<span class="line"><span class="token header"><span class="token header-name keyword">If-None-Match</span><span class="token punctuation">:</span> <span class="token header-value">&quot;123456&quot;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><p><strong>协商缓存的工作流程</strong></p><ol><li>客户端首次请求资源，服务器返回资源并设置 <code>Last-Modified</code> 或 <code>ETag</code>。</li><li>客户端再次请求时，携带 <code>If-Modified-Since</code> 或 <code>If-None-Match</code>。</li><li>服务器验证资源是否修改： <ul><li>如果未修改，返回 <code>304 Not Modified</code>，客户端使用本地缓存。</li><li>如果已修改，返回新的资源（状态码 <code>200</code>）。</li></ul></li></ol><p><strong>协商缓存的命中与未命中</strong></p><ul><li><strong>命中</strong>：状态码为 <code>304 Not Modified</code>。</li><li><strong>未命中</strong>：状态码为 <code>200</code>，返回新的资源。</li></ul><hr><p><strong>3. 强缓存与协商缓存的区别</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>强缓存</strong></th><th><strong>协商缓存</strong></th></tr></thead><tbody><tr><td><strong>是否发送请求</strong></td><td>否，直接从缓存读取</td><td>是，向服务器验证缓存是否有效</td></tr><tr><td><strong>状态码</strong></td><td><code>200 (from disk cache)</code> 或 <code>200 (from memory cache)</code></td><td><code>304 Not Modified</code></td></tr><tr><td><strong>响应头字段</strong></td><td><code>Cache-Control</code>、<code>Expires</code></td><td><code>Last-Modified</code>、<code>ETag</code></td></tr><tr><td><strong>请求头字段</strong></td><td>无</td><td><code>If-Modified-Since</code>、<code>If-None-Match</code></td></tr><tr><td><strong>优先级</strong></td><td>优先使用强缓存，失效后使用协商缓存</td><td>强缓存失效后触发</td></tr></tbody></table><hr><p><strong>4. 实际应用中的缓存策略</strong></p><ol><li><p><strong>静态资源（如 CSS、JS、图片）</strong>：</p><ul><li>使用强缓存，设置较长的 <code>max-age</code>（如一年）。</li><li>通过文件名哈希（如 <code>app.12345.js</code>）确保资源更新后客户端能获取最新版本。</li></ul></li><li><p><strong>动态资源（如 API 数据）</strong>：</p><ul><li>使用协商缓存，设置 <code>Cache-Control: no-cache</code> 或 <code>max-age=0</code>。</li><li>通过 <code>ETag</code> 或 <code>Last-Modified</code> 验证资源是否更新。</li></ul></li></ol><hr><p><strong>5. 示例</strong><strong>强缓存示例</strong></p><div class="language-http line-numbers-mode" data-highlighter="prismjs" data-ext="http" data-title="http"><pre><code><span class="line"><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK</span></span></span>
<span class="line"><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">max-age=3600, public</span></span></span>
<span class="line"><span class="token header"><span class="token header-name keyword">Expires</span><span class="token punctuation">:</span> <span class="token header-value">Wed, 21 Oct 2023 08:28:00 GMT</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>协商缓存示例</strong></p><div class="language-http line-numbers-mode" data-highlighter="prismjs" data-ext="http" data-title="http"><pre><code><span class="line"><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK</span></span></span>
<span class="line"><span class="token header"><span class="token header-name keyword">Last-Modified</span><span class="token punctuation">:</span> <span class="token header-value">Wed, 21 Oct 2023 07:28:00 GMT</span></span></span>
<span class="line"><span class="token header"><span class="token header-name keyword">ETag</span><span class="token punctuation">:</span> <span class="token header-value">&quot;123456&quot;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>协商缓存验证（未修改）</strong></p><div class="language-http line-numbers-mode" data-highlighter="prismjs" data-ext="http" data-title="http"><pre><code><span class="line"><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/resource</span> <span class="token http-version property">HTTP/1.1</span></span></span>
<span class="line"><span class="token header"><span class="token header-name keyword">If-Modified-Since</span><span class="token punctuation">:</span> <span class="token header-value">Wed, 21 Oct 2023 07:28:00 GMT</span></span></span>
<span class="line"><span class="token header"><span class="token header-name keyword">If-None-Match</span><span class="token punctuation">:</span> <span class="token header-value">&quot;123456&quot;</span></span></span>
<span class="line"></span>
<span class="line"><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">304</span> <span class="token reason-phrase string">Not Modified</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p><strong>总结</strong></p><ul><li><strong>强缓存</strong>：直接从本地缓存读取资源，不发送请求。</li><li><strong>协商缓存</strong>：向服务器验证缓存是否有效，返回 <code>304</code> 或新资源。</li><li>实际开发中，通常结合两者使用：优先强缓存，失效后使用协商缓存。</li></ul><h2 id="fetch请求-设计一个不会超时的fetch请求" tabindex="-1"><a class="header-anchor" href="#fetch请求-设计一个不会超时的fetch请求"><span>fetch请求, 设计一个不会超时的fetch请求</span></a></h2>`,90)]))}const c=s(i,[["render",o],["__file","index.html.vue"]]),r=JSON.parse('{"path":"/interview/%E7%BD%91%E7%BB%9C/","title":"","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"http和https","slug":"http和https","link":"#http和https","children":[]},{"level":2,"title":"https的加密流程","slug":"https的加密流程","link":"#https的加密流程","children":[]},{"level":2,"title":"如何理解OSI七层模型?","slug":"如何理解osi七层模型","link":"#如何理解osi七层模型","children":[]},{"level":2,"title":"三次握手和四次挥手","slug":"三次握手和四次挥手","link":"#三次握手和四次挥手","children":[{"level":3,"title":"TCP 三次握手（建立连接）","slug":"tcp-三次握手-建立连接","link":"#tcp-三次握手-建立连接","children":[]},{"level":3,"title":"TCP 四次挥手（断开连接）","slug":"tcp-四次挥手-断开连接","link":"#tcp-四次挥手-断开连接","children":[]},{"level":3,"title":"为什么需要三次握手和四次挥手？","slug":"为什么需要三次握手和四次挥手","link":"#为什么需要三次握手和四次挥手","children":[]},{"level":3,"title":"示意图","slug":"示意图","link":"#示意图","children":[]}]},{"level":2,"title":"TCP协议和UDP协议的区别","slug":"tcp协议和udp协议的区别","link":"#tcp协议和udp协议的区别","children":[]},{"level":2,"title":"说说对WebSocket的理解？应用场景？","slug":"说说对websocket的理解-应用场景","link":"#说说对websocket的理解-应用场景","children":[]},{"level":2,"title":"应用场景","slug":"应用场景","link":"#应用场景","children":[]},{"level":2,"title":"说说地址栏输入 URL 敲下回车后发生了什么?","slug":"说说地址栏输入-url-敲下回车后发生了什么","link":"#说说地址栏输入-url-敲下回车后发生了什么","children":[]},{"level":2,"title":"DNS解析过程","slug":"dns解析过程","link":"#dns解析过程","children":[]},{"level":2,"title":"http发送请求和dns发送一个请求的区别以及哪个更快","slug":"http发送请求和dns发送一个请求的区别以及哪个更快","link":"#http发送请求和dns发送一个请求的区别以及哪个更快","children":[]},{"level":2,"title":"常见的HTTP请求头","slug":"常见的http请求头","link":"#常见的http请求头","children":[]},{"level":2,"title":"HTTP缓存（强缓存、协商缓存）","slug":"http缓存-强缓存、协商缓存","link":"#http缓存-强缓存、协商缓存","children":[]},{"level":2,"title":"fetch请求, 设计一个不会超时的fetch请求","slug":"fetch请求-设计一个不会超时的fetch请求","link":"#fetch请求-设计一个不会超时的fetch请求","children":[]}],"git":{"updatedTime":1740721153000,"contributors":[{"name":"LiHegui","username":"LiHegui","email":"1487647822@qq.com","commits":3,"url":"https://github.com/LiHegui"}]},"filePathRelative":"interview/网络/index.md"}');export{c as comp,r as data};
