import{_ as s,c as a,a as e,o as p}from"./app-DPjPDnzl.js";const t={};function l(o,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h1 id="已发博客-李和贵" tabindex="-1"><a class="header-anchor" href="#已发博客-李和贵"><span>已发博客-李和贵</span></a></h1><h1 id="react-memo" tabindex="-1"><a class="header-anchor" href="#react-memo"><span>React.memo</span></a></h1><blockquote><p>React 的渲染机制，组件内部的 state 或者 props 一旦发生修改，整个组件树都会被重新渲染一次，即时子组件的参数没有被修改，甚至无状态组件 会造成性能浪费</p></blockquote><p><strong>React.memo 是 React 官方提供的一个高阶组件，用于缓存我们的需要优化的组件</strong></p><blockquote><p>React 中的组件被设计为在状态或 props 值发生变化时重新渲染。但是，这可能会影响应用程序的性能，因为即使更改只是为了影响父组件，附加到父组件的所有其他子组件都将重新呈现。当父组件重新渲染时，其所有子组件也会重新渲染。 React Memo 是一个高阶组件，它包装组件以记忆渲染的输出并避免不必要的渲染。这提高了性能，因为它会记住结果并跳过渲染以重用上次渲染的结果。</p></blockquote><p><strong>已经记忆化的组件，怎么触发更新</strong></p><ul><li>即使一个组件被记忆化了，当它自身的状态发生变化时，它仍然会重新渲染。memoization 只与从父组件传递给组件的 props 有关。</li><li>即使组件已被记忆化，当其使用的 context 发生变化时，它仍将重新渲染。记忆化只与从父组件传递给组件的 props 有关。</li><li>useMemo <ul><li>见拓展（下面）</li></ul></li><li>自定义比较函数（见Memo参数-第二个参数，下面）</li></ul><h2 id="两种方式" tabindex="-1"><a class="header-anchor" href="#两种方式"><span>两种方式</span></a></h2><ul><li>直接创建(类式创建)<div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">const</span> myComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">/* render using props */</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> myComponent<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>函数组件</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">    <span class="token keyword">const</span> <span class="token function-variable function">myComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">/* render using props */</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">export</span> <span class="token keyword">const</span> MemoizedComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>myComponent<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>仅当 props 值发生变化或组件的状态和上下文发生变化时，memo组件才会重新渲染</strong></p><h2 id="参数" tabindex="-1"><a class="header-anchor" href="#参数"><span>参数</span></a></h2><p>React.memo(Component, arePropsEqual?)</p><ul><li>Component 组件</li><li>arePropsRqual 可选参数，为一个函数 接受两个参数： <blockquote><p>一个函数，接受两个参数：组件的前一个 props 和新的 props。如果旧的和新的 props 相等，即组件使用新的 props 渲染的输出和表现与旧的 props 完全相同，则它应该返回 true。否则返回 false。通常情况下，你不需要指定此函数。默认情况下，React 将使用 Object.is 比较每个 prop。</p></blockquote></li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">/* 使用 props 渲染 */</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">shouldMemo</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">/*</span>
<span class="line">  如果把 nextProps 传入 render 方法的返回结果与</span>
<span class="line">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span>
<span class="line">  否则返回 false</span>
<span class="line">  */</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">,</span> shouldMemo<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景</span></a></h2><ul><li><p>当props没有改变时跳过重新渲染</p></li><li><p>使用state更新记忆化(memoized)组件</p></li></ul><p><strong>切记，不可以普遍使用该组件，不能都进行缓存，太多缓存，会造成负优化</strong></p><h1 id="拓展" tabindex="-1"><a class="header-anchor" href="#拓展"><span>拓展</span></a></h1><h2 id="usememo" tabindex="-1"><a class="header-anchor" href="#usememo"><span>useMemo</span></a></h2><h3 id="usememo-calculatevalue-dependencies" tabindex="-1"><a class="header-anchor" href="#usememo-calculatevalue-dependencies"><span>useMemo(calculateValue, dependencies)</span></a></h3><blockquote><p>在组件的顶层调用 useMemo 来缓存每次重新渲染都需要计算的结果，它在每次重新渲染的时候能够缓存计算结果</p></blockquote><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">    const cachedValue = useMemo(calculateValue, dependenies)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>calculateValue 要缓存计算的函数。之后组件更新，如果dependenies没有发生变化，React将直接返回相同值。否则，将会再次调用calculateValue并返回最新结果，然后进行缓存以便下次进行使用。</li><li>dependenies 跟一般钩子的依赖项作用一样</li></ul><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://react.docschina.org/reference/react/memo" target="_blank" rel="noopener noreferrer">官网</a><a href="https://juejin.cn/post/7188041140963115066?searchId=2023080116574982B3D403AE15790335B3" target="_blank" rel="noopener noreferrer">掘金</a></p>`,26)]))}const c=s(t,[["render",l],["__file","Memo.html.vue"]]),r=JSON.parse('{"path":"/tools/docs/repository/React/Memo.html","title":"已发博客-李和贵","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"两种方式","slug":"两种方式","link":"#两种方式","children":[]},{"level":2,"title":"参数","slug":"参数","link":"#参数","children":[]},{"level":2,"title":"应用场景","slug":"应用场景","link":"#应用场景","children":[]},{"level":2,"title":"useMemo","slug":"usememo","link":"#usememo","children":[{"level":3,"title":"useMemo(calculateValue, dependencies)","slug":"usememo-calculatevalue-dependencies","link":"#usememo-calculatevalue-dependencies","children":[]}]}],"git":{"updatedTime":1738722167000,"contributors":[{"name":"LiHegui","username":"LiHegui","email":"1487647822@qq.com","commits":1,"url":"https://github.com/LiHegui"}]},"filePathRelative":"tools/docs/repository/React/Memo.md"}');export{c as comp,r as data};
