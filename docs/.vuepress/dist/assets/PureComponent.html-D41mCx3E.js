import{_ as o,c as n,b as e,d as r,o as p}from"./app-DPjPDnzl.js";const a={};function l(u,t){return p(),n("div",null,t[0]||(t[0]=[e("h1",{id:"purecomponent",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#purecomponent"},[e("span",null,"PureComponent")])],-1),e("blockquote",null,[e("p",null,"React.PureComponent 与 React.Component 很相似。两者的区别在于 React.Component 并未实现 shouldComponentUpdate()，而 React.PureComponent 中以浅层对比 prop 和 state 的方式来实现了该函数。")],-1),e("p",null,[e("strong",null,"原理")],-1),e("p",null,"当组件更新时，如果组件的 props 和state 都没发生改变， render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。 这里需要注意的是，这里的对比都是浅层对比",-1),e("p",null,[e("strong",null,"摘自官网"),r(" React.PureComponent 中的 shouldComponentUpdate() 仅作对象的浅层比较。如果对象中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。仅在你的 props 和 state 较为简单时，才使用 React.PureComponent，或者在深层数据结构发生变化时调用 forceUpdate() 来确保组件被正确地更新。你也可以考虑使用 immutable 对象加速嵌套数据的比较。")],-1),e("p",null,"此外，React.PureComponent 中的 shouldComponentUpdate() 将跳过所有子组件树的 prop 更新。因此，请确保所有子组件也都是“纯”的组件。",-1)]))}const s=o(a,[["render",l],["__file","PureComponent.html.vue"]]),c=JSON.parse('{"path":"/repository/React/PureComponent.html","title":"PureComponent","lang":"zh-CN","frontmatter":{},"headers":[],"git":{"updatedTime":1738722167000,"contributors":[{"name":"LiHegui","username":"LiHegui","email":"1487647822@qq.com","commits":1,"url":"https://github.com/LiHegui"}]},"filePathRelative":"repository/React/PureComponent.md"}');export{s as comp,c as data};
