import{_ as s,c as a,a as e,o as i}from"./app-DPjPDnzl.js";const p={};function l(t,n){return i(),a("div",null,n[0]||(n[0]=[e(`<p><a href="&#39;https://juejin.cn/post/7190726242042118200#heading-16&#39;">参考文章</a></p><h1 id="diff-算法" tabindex="-1"><a class="header-anchor" href="#diff-算法"><span>diff 算法</span></a></h1><ul><li>diff算法的触发场景 diff算法本质上是一个对比的方法，核心就是旧的DOM组更新为新DOM组时，如何更新效率才能最高。</li><li>v-for循环时，key的意义 我们在比较过程中（可以举个ul&gt;li的小例子），要确认两个dom是否有变化，是否相同。 利用vnode的type和key进行对比，如果两个type和node相同，那就可以认为相同。<div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts" data-title="ts"><pre><code><span class="line"><span class="token keyword">interface</span> <span class="token class-name">VNode</span> <span class="token punctuation">{</span></span>
<span class="line">type<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span></span>
<span class="line">key<span class="token operator">:</span> <span class="token builtin">string</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token doc-comment comment">/**</span>
<span class="line">* 根据 key || type 判断是否为相同类型节点</span>
<span class="line">* <span class="token keyword">@param</span> <span class="token parameter">node1</span> </span>
<span class="line">* <span class="token keyword">@param</span> <span class="token parameter">node2</span> </span>
<span class="line">* <span class="token keyword">@returns</span> </span>
<span class="line">*/</span></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isSameVNodeType</span><span class="token punctuation">(</span>node1<span class="token operator">:</span> VNode<span class="token punctuation">,</span> node2<span class="token operator">:</span> VNode<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> node1<span class="token punctuation">.</span>type <span class="token operator">===</span> node2<span class="token punctuation">.</span>type <span class="token operator">&amp;&amp;</span> node1<span class="token punctuation">.</span>key <span class="token operator">===</span> node2<span class="token punctuation">.</span>key</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>diff算法的五大步 <ol><li>自前向后对比 自前向后的diff对比中，会依次获取相同下标oldChildren和newChild。 如果oldChildren和newChild为相同的Vnode，则直接通过patch进行打补丁即可。 如果oldChildren和newCHild为不相同的VNode,则会跳出循环。 通过第一步，我们可以处理相同的node,直到遇见不同的VNode为止。</li><li>自后向前对比 这一步跟上一步返回来，很好理解，自减一进行比较，也是直到不同的VNode。</li><li>新节点多余旧节点，需要挂载</li><li>旧节点多于新节点，需要卸载 第一步和第二步节点前提都是节点数量一致，3、4步骤是处理新旧节点</li><li>乱序 乱序为第二部分 我们需要知道一个概念，最长递增子序列 在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。 最长递增子序列的确定，可以帮助我们减少移动的次数，从而提升性能。 乱序之下的diff是最复杂的一块情景 - 创建一个 <code>&lt;key（新节点的 key）:index（新节点的位置）&gt;</code> 的 Map 对象 keyToNewIndexMap。通过该对象可知：新的 child（根据 key 判断指定 child） 更新后的位置（根据对应的 index 判断）在哪里 - 循环 oldChildren ，并尝试进行 patch（打补丁）或 unmount（删除）旧节点 - 处理 移动和挂载</li></ol></li></ul>`,3)]))}const c=s(p,[["render",l],["__file","index.html.vue"]]),d=JSON.parse('{"path":"/interview/Vue3/diff/","title":"diff 算法","lang":"zh-CN","frontmatter":{},"headers":[],"git":{"updatedTime":1738722167000,"contributors":[{"name":"LiHegui","username":"LiHegui","email":"1487647822@qq.com","commits":1,"url":"https://github.com/LiHegui"}]},"filePathRelative":"interview/Vue3/diff/index.md"}');export{c as comp,d as data};
