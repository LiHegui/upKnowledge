import{_ as i,c as e,a as g,o as s}from"./app-DPjPDnzl.js";const a={};function l(r,t){return s(),e("div",null,t[0]||(t[0]=[g('<h2 id="说说你对git-reset-和-git-revert-的理解-区别" tabindex="-1"><a class="header-anchor" href="#说说你对git-reset-和-git-revert-的理解-区别"><span>说说你对git reset 和 git revert 的理解？区别?</span></a></h2><p>git reset和git revert都是用来撤销更改的命令。</p><ul><li>git reset git reset命令会将分支指针和HEAD指针移动到指定的提交，从而撤销之前的提交。这意味着同时也会删除 git的提交记录。 功能如下 <ul><li>撤销更改 可以使用reset来撤销你对代码库所做的更改，并将HEAD指针移动到以前的提交。 可以使用git reset HEAD~1撤销到最近的一次提交</li><li>移动分支 本地分支与远程分支同步到远程分支最新提交的地方，git reset --head</li><li>取消暂存文件 git reset --mixed将取消暂存你所有的暂存更改</li></ul></li><li>git revert git revert命令会创建一个新的提交，该提交是撤销了之前的提交。也就是说包含了之前的提交相反的更改。 之前的提交记录有一直都会在，也就是说这种做法更加保险。</li></ul><h2 id="git在错误提交之后-又有几次提交-如何提出这次错误提交-又不影响后面的提交" tabindex="-1"><a class="header-anchor" href="#git在错误提交之后-又有几次提交-如何提出这次错误提交-又不影响后面的提交"><span>git在错误提交之后，又有几次提交，如何提出这次错误提交，又不影响后面的提交</span></a></h2><p>两种方法可以回滚错误提交</p><ul><li>git revert HEAD 这将创建一个新的提交，该提交将撤销最新的提交并还原更改。新提交的消息将包含有关回滚的信息</li><li>git reset --hard HEAD~1 如果您想完全删除最新的提交并将更改还原到之前的状态，可以使用以下命令。谨慎使用 剩下的就是如何恢复后面的提交。 git reflog =&gt; 将列出所有的操作记录，包括已删除的提交。找到你要还原的提交，进行还原新提交 git cherry-pick COMMIT~HASH =&gt;COMMIT~HASH是提交的的hash值。这将创建一个新的提交，包含你要还原的更改</li></ul><h2 id="说说你对git-rebase-和-git-merge的理解-区别" tabindex="-1"><a class="header-anchor" href="#说说你对git-rebase-和-git-merge的理解-区别"><span>说说你对git rebase 和 git merge的理解？区别？</span></a></h2><p>两者都是进行合并分支的操作</p><ul><li><p>git marge xxx =&gt;是将当前分支和xxx分支进行合并，首先找到里两个分支的最新提交，然后找到两个分支的历史最近祖先，最后将三者合并生成一个新的提交</p></li><li><p>git rebase xxx =&gt;是将当前分支嫁接到xxx分支，首先找到两个分支的最近提交祖先，将当前分支在最近祖先后的所有提交修改为暂存提交文件，然后找到目标分支的最新提交位置，最后将暂存的提交文件依次应用到目标分支的最新位置</p></li></ul><p>两者的区别 =&gt;marge的话会将两个分支合并起来，会保留两个分支的历史提交，方便进行回滚操作 rebase的话会将当前分支嫁接到目标分支，可以有效地合并所有的提交，但是会改变提交历史，影响回滚操作</p><h2 id="说说对git-pull-和-git-fetch-的理解-有什么区别" tabindex="-1"><a class="header-anchor" href="#说说对git-pull-和-git-fetch-的理解-有什么区别"><span>说说对git pull 和 git fetch 的理解？有什么区别？</span></a></h2><ul><li><p>git fetch &lt;远程主机名origin&gt; &lt;远程分支名master&gt;:&lt;本地分支名temp&gt; 将远程的远程origin仓库的远程master分支下载代码到本地并创建一个新分支temp 如果没有：temp，则是下载到当前分支，这里的git fetch不会进行合并，需要手动git marge进行合并</p></li><li><p>git pull &lt;远程主机名origin&gt; &lt;远程分支名master&gt;:&lt;本地分支名branchtest&gt; 将远程的远程origin仓库的远程master分支的代码拉取下来，然后与本地的branchtest分支进行合并 如果没有:branchtest，则是和当前分支进行合并</p></li></ul><p>相同点：都是可以做到代码更新的作用 区别: git pull=&gt;相当于远程仓库拉取最新的代码，然后自动与本地分支进行合并，所以可能会覆盖本地的修改 git pull相当于git fetch + git marge</p><p>git fetch=&gt;也是从远程获取最新代码，然后根据实际情况决定是否进行合并操作</p><h2 id="说说你对git-stash-的理解-应用场景" tabindex="-1"><a class="header-anchor" href="#说说你对git-stash-的理解-应用场景"><span>说说你对git stash 的理解？应用场景？</span></a></h2><p>stash本意是暂存存放的意思，可以理解保存当前进度，吧暂存区和工作区的工作内容保存到到一个栈中，可以在后续的任何分支任何时候将栈中的内容重新应用出来</p><ul><li><p>git stash =&gt; 用于保存当前进度，吧暂存区和工作区的代码改动保存起来</p></li><li><p>git stash save =&gt; 和git stash作用一样，目前已经被弃用</p></li><li><p>git stash list =&gt; 用于查看当前保存区中所有的存储列表，它会显示每个存储条目的索引、描述内容以及存储条目的更改数量 执行实例： stash@{0}: On master: My temporary changes stash@{1}: On feature-branch: Another set of changes 在第一条中，master代表分支，My temporary changes代表内容描述 可以用git stash apply或者git stash pop应用或者弹出存储条目 =&gt; git stash pop stash@{0}</p></li><li><p>git stash pop =&gt; 默认读取存储栈中最后一次提交的内容，也就是找到栈顶stash内容恢复到工作区，同时删除该存储条目，也可以通过git stash pop stash@{0}指定需要恢复的存储条目，恢复之后如果发生冲突，需要手动修复或者新建分支来解决</p></li><li><p>git stash apply =&gt; 和git stash pop作用一样，都是恢复一次提交内容到工作区，但是不会在存储栈中删除该存储条目</p></li><li><p>git stash show =&gt; 用于查看存储栈中一个存储条目的更改内容，默认查看最新一次的存储条目，也可以通过添加索引来查看指定存储条目的更改内容</p></li><li><p>git stash drop =&gt; 用于移除指定索引的存储条目</p></li><li><p>git stash clear =&gt; 用于删除所有的存储条目</p></li></ul><p>应用场景： 1.当开发进行一半时，需要同步远程代码时，如果远程和本地没有冲突，可以使用git pull直接拉取 如果有冲突时，git pull不能覆盖当前的修改可以执行 git stash =&gt; git pull =&gt; git stash pop来解决</p><p>2.当开发进行了一半，需要去操作另一个分支时，可以用git stash进行缓存当前更改的内容，可以执行 git stash =&gt; git commit -m &quot;修改内容&quot; =&gt; git stash pop来解决</p><h2 id="说说git-中-head、工作树和索引之间的区别" tabindex="-1"><a class="header-anchor" href="#说说git-中-head、工作树和索引之间的区别"><span>说说Git 中 HEAD、工作树和索引之间的区别？</span></a></h2><p>三者没有大致的共同点： HEAD指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是指向当前最新的提交 工作树通常指当前的工作目录，是正在查看或者正在修改的文件地方 索引是一个中间状态，工作树的代码需要先git add添加索引到索引区域才能git commit到git仓库</p><h2 id="命令行git指令" tabindex="-1"><a class="header-anchor" href="#命令行git指令"><span>命令行git指令</span></a></h2><p>mkdir xx（文件名）：创建指定文件 cd xx（文件名）：跳转到指定目录 git branch -d xx（分支名）：删除指定本地分支 git push origin -d xx（分支名）：删除指定远程分支 git status：查看当前分支修改状态 git log：查看提交日志 git blame -L 1,100 文件地址：查看文件中1-100行的改动记录 vi xx（文件地址）：在终端编辑文件 i：修改文件 wq：退出编辑文件 git pull --rebase origin master：拉取代码 git push -u origin master：推送代码 git config -e：修改git初始化配置文件 git tag -a XX（tag名）-m &quot;提交注释&quot; xx（提交版本号）：项目打tag git push -u origin XX（tag名）：推送tag</p>',23)]))}const p=i(a,[["render",l],["__file","index.html.vue"]]),n=JSON.parse('{"path":"/tools/docs/interview/git/","title":"","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"说说你对git reset 和 git revert 的理解？区别?","slug":"说说你对git-reset-和-git-revert-的理解-区别","link":"#说说你对git-reset-和-git-revert-的理解-区别","children":[]},{"level":2,"title":"git在错误提交之后，又有几次提交，如何提出这次错误提交，又不影响后面的提交","slug":"git在错误提交之后-又有几次提交-如何提出这次错误提交-又不影响后面的提交","link":"#git在错误提交之后-又有几次提交-如何提出这次错误提交-又不影响后面的提交","children":[]},{"level":2,"title":"说说你对git rebase 和 git merge的理解？区别？","slug":"说说你对git-rebase-和-git-merge的理解-区别","link":"#说说你对git-rebase-和-git-merge的理解-区别","children":[]},{"level":2,"title":"说说对git pull 和 git fetch 的理解？有什么区别？","slug":"说说对git-pull-和-git-fetch-的理解-有什么区别","link":"#说说对git-pull-和-git-fetch-的理解-有什么区别","children":[]},{"level":2,"title":"说说你对git stash 的理解？应用场景？","slug":"说说你对git-stash-的理解-应用场景","link":"#说说你对git-stash-的理解-应用场景","children":[]},{"level":2,"title":"说说Git 中 HEAD、工作树和索引之间的区别？","slug":"说说git-中-head、工作树和索引之间的区别","link":"#说说git-中-head、工作树和索引之间的区别","children":[]},{"level":2,"title":"命令行git指令","slug":"命令行git指令","link":"#命令行git指令","children":[]}],"git":{"updatedTime":1738722167000,"contributors":[{"name":"LiHegui","username":"LiHegui","email":"1487647822@qq.com","commits":1,"url":"https://github.com/LiHegui"}]},"filePathRelative":"tools/docs/interview/git/index.md"}');export{p as comp,n as data};
