import{_ as l,c as i,a as r,b as s,e as t,f as n,r as o,o as c,d as p}from"./app-DPjPDnzl.js";const d={};function h(u,e){const a=o("RouteLink");return c(),i("div",null,[e[1]||(e[1]=r('<h1 id="sourcemap映射的原理" tabindex="-1"><a class="header-anchor" href="#sourcemap映射的原理"><span>sourcemap映射的原理</span></a></h1><h1 id="javascript本地存储的方式有哪些-区别及应用场景" tabindex="-1"><a class="header-anchor" href="#javascript本地存储的方式有哪些-区别及应用场景"><span>Javascript本地存储的方式有哪些？区别及应用场景？</span></a></h1><ul><li>cookie =&gt;是一种小型文本文件，主要是为了辨别用户身份信息而储存在用户本地的数据，为解决http无状态连接导致的问题。内存很小，通常只有4kb，数据可以在浏览器和服务器之间传递，适用于不同页面之间共享数据的情况。</li><li>localStorage =&gt;html5的新方法，兼容ie8以上浏览器，是一种持久化的储存，除非手动删除，否则一直存在。它只能通过js进行操作，而且之能储存字符串类型的数据，适用于需要在浏览器存储大量数据的情况。</li><li>sessionStorage =&gt;方法和localStorage类似，但是不是持久化存储，当前浏览器窗口关闭时，数据就会删除，适用于一次性登录的情况</li></ul><h1 id="什么是xss攻击" tabindex="-1"><a class="header-anchor" href="#什么是xss攻击"><span>什么是xss攻击？</span></a></h1><h1 id="什么是csrf攻击" tabindex="-1"><a class="header-anchor" href="#什么是csrf攻击"><span>什么是csrf攻击？</span></a></h1><h1 id="对浏览器缓存机制的了解" tabindex="-1"><a class="header-anchor" href="#对浏览器缓存机制的了解"><span>对浏览器缓存机制的了解？</span></a></h1><p>当浏览器在请求资源的时候，会先检查本地缓存中是否存在该资源的缓存，如果该缓存存在而且没有过期，就直接从本地缓存中读取资源，而不需要重新请求服务器获取资源，从而提高页面的加载速度和性能</p><h2 id="什么是协商缓存和强缓存" tabindex="-1"><a class="header-anchor" href="#什么是协商缓存和强缓存"><span>什么是协商缓存和强缓存？</span></a></h2><ul><li><p>强缓存：通过http响应头的expires和cache-control字段来控制缓存时间，浏览器在缓存时间内可以直接使用本地缓存资源。expires字段是一个时间戳，表示资源的过期时间；cache-control字段则可以指定缓存时间，是否允许缓存，是否需要验证等。使用强缓存可以减少服务器的负载和网络请求，提高页面的加载速度和性能</p></li><li><p>协商缓存：通过http响应头的last-modidied和etag字段来控制缓存验证，服务器会比较资源的修改时间或者唯一标识是否发生了变化，如果没发生变化，就返回一个304 not modified响应，通知浏览器可以使用本地缓存资源。协商缓存可以有效解决缓存过期后的缓存更新问题，减少网络请求，但需要服务器的支持。</p></li></ul><h2 id="浏览器的渲染流程" tabindex="-1"><a class="header-anchor" href="#浏览器的渲染流程"><span>浏览器的渲染流程</span></a></h2><ul><li>浏览器会<strong>解析</strong>三个东西 <ol><li>HTML字符串描述了一个页面的结构，浏览器会把HTML结构字符串解析转换DOM树形结构。构建对应的DOM树 字节数据 =&gt; 字符串 =&gt; Token =&gt; Node =&gt; DOM</li><li>CSS 的解析在经历了从字节数据、字符串、标记化后，最终也会形成一颗 CSSOM 树, 不会阻塞构建DOM树 但是解析了JS脚本，构建CSSOM也会阻塞DOM的构建，解析CSS会产生CSS规则树</li><li>javascript脚本, 等到Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree 如果主线程解析到 script 位置，会停止解析HTML，等待 JS 文件下载好，并将全局代码解析并执行完成后，才能继续解析 HTML 处理JS <ul><li>解析JavaScript代码</li><li>执行JavaScript代码</li><li>修改DOM和样式</li><li>异步加载 async defer控制脚本的加载和执行时机 没有async和defer, JS脚本会立即执行 <ol><li>async 异步加载，异步加载好了就执行</li><li>defer 延迟执行， 会放到HTML解析之后，有顺序的加载</li></ol></li></ul></li></ol></li><li>解析完成之后，浏览器会通过DOM Tree和CSS Rule Tree 来构造 Rendering Tree</li><li>最后进行绘制 <strong>因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以需要等待js执行完成。这就是 JS 会阻塞 HTML 解析的根本原因。 这也是都建议将 script 标签放在 body 标签底部的原因。</strong></li><li>DOM 树和 CSSOM 树合并成了一颗带有样式的 DOM 树</li><li>根据DOM树开始布局</li><li>分层</li><li>生成绘制指令</li><li>分块 为了提高渲染性能，浏览器会将页面划分成多个块（或称为矩形区域）。每个块都有自己的绘制指令</li><li>光栅化 光栅化是将矢量图形转换为位图的过程。浏览器会将每个块的绘制指令转换为位图。</li><li>绘制</li></ul><p><a href="https://juejin.cn/post/6844903815758479374" target="_blank" rel="noopener noreferrer">掘金好文</a></p><p><strong>延申：async defer</strong></p><ul><li>async 此属性表示脚本应当异步地执行。这意味着，当浏览器遇到async脚本时，它会立即开始下载脚本，而不等待其他页面加载完成。一旦脚本下载完成，浏览器会暂停当前的工作（如解析HTML），执行脚本，然后继续解析剩下的HTML。需要注意的是，使用async属性的脚本可能会在DOMContentLoaded事件触发之前就执行，这可能会导致一些未定义的行为。</li><li>defer 此属性表示脚本将在文档解析完成后，但在DOMContentLoaded事件触发之前执行。这意味着，使用defer属性的脚本将在所有DOM内容都加载完成后执行，但不会阻塞页面的渲染。值得注意的是，使用defer的脚本按照它们在HTML中出现的顺序执行。</li><li>script 这是标准的script标签，没有额外的属性。如果没有使用async或defer属性，那么脚本会在页面加载时同步执行。</li></ul><h2 id="不同标签页通信" tabindex="-1"><a class="header-anchor" href="#不同标签页通信"><span>不同标签页通信</span></a></h2><p>SharedWorker</p><p>是一种特殊的Web Worker，可以在多个浏览器上下文中运行，例如多个窗口、iframe或其他worker。与普通worker不同，SharedWorker具有不同的全局作用域，即SharedWorkerGlobalScope。</p><p>在多个页面间共享信息时，只要保证创建时的第一个参数相同，就可以在多页签间共享信息。这是因为当在页签的html中创建SharedWorker时，如果第一个参数相同，则视为同一线程。</p><p>SharedWorker是一种使多个页面能够共享信息的Web Worker API，它在实现多页签间通信时非常有用</p><p>var myWorker = new SharedWorker(&#39;worker.js&#39;);</p><p>self.onmessage = function(event) {<br> console.log(&#39;Message received from main script:&#39;, event.data);<br> // 返回结果给主页面<br> postMessage(&#39;Message received!&#39;);<br> };</p><p>myWorker.postMessage(&#39;Hello, worker!&#39;);</p><ul><li>postMessage</li></ul><h2 id="说说地址栏输入-url-敲下回车后发生了什么" tabindex="-1"><a class="header-anchor" href="#说说地址栏输入-url-敲下回车后发生了什么"><span>说说地址栏输入 URL 敲下回车后发生了什么?</span></a></h2><ol><li>URL解析</li><li>DNS查询</li><li>TCP链接</li><li>HTTP请求</li><li>相应请求</li><li>页面渲染</li></ol><h2 id="说一下你理解的浏览器缓存" tabindex="-1"><a class="header-anchor" href="#说一下你理解的浏览器缓存"><span>说一下你理解的浏览器缓存</span></a></h2>',26)),s("p",null,[t(a,{to:"/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.html"},{default:n(()=>e[0]||(e[0]=[p("浏览器缓存")])),_:1})])])}const f=l(d,[["render",h],["__file","index.html.vue"]]),g=JSON.parse('{"path":"/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/","title":"sourcemap映射的原理","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"什么是协商缓存和强缓存？","slug":"什么是协商缓存和强缓存","link":"#什么是协商缓存和强缓存","children":[]},{"level":2,"title":"浏览器的渲染流程","slug":"浏览器的渲染流程","link":"#浏览器的渲染流程","children":[]},{"level":2,"title":"不同标签页通信","slug":"不同标签页通信","link":"#不同标签页通信","children":[]},{"level":2,"title":"说说地址栏输入 URL 敲下回车后发生了什么?","slug":"说说地址栏输入-url-敲下回车后发生了什么","link":"#说说地址栏输入-url-敲下回车后发生了什么","children":[]},{"level":2,"title":"说一下你理解的浏览器缓存","slug":"说一下你理解的浏览器缓存","link":"#说一下你理解的浏览器缓存","children":[]}],"git":{"updatedTime":1738722167000,"contributors":[{"name":"LiHegui","username":"LiHegui","email":"1487647822@qq.com","commits":1,"url":"https://github.com/LiHegui"}]},"filePathRelative":"interview/浏览器/index.md"}');export{f as comp,g as data};
