import{_ as a,c as i,a as l,o as t}from"./app-DPjPDnzl.js";const n={};function s(r,e){return t(),i("div",null,e[0]||(e[0]=[l(`<h1 id="类" tabindex="-1"><a class="header-anchor" href="#类"><span>类</span></a></h1><p>类的成员</p><ul><li>字段</li><li>构造函数 类实例化时调用，可以为类的对象分配内存。</li><li>方法</li></ul><h2 id="继承" tabindex="-1"><a class="header-anchor" href="#继承"><span>继承</span></a></h2><pre><code>使用extends关键字，类继承后子类可以对父类进行重写，super关键字是对父类的引用，可以调用父类的属性和方法    
</code></pre><h2 id="修饰符" tabindex="-1"><a class="header-anchor" href="#修饰符"><span>修饰符</span></a></h2><ul><li>公共 关键字public,可以自用的访问类的属性</li><li>private 私有属性，无法被继承，实例对象不能访问该属性，继承的子类也不能访问</li><li>protect 受保护修饰符，实例对象不能访问该属性，但是在其子类中能够使用该属性</li><li>readonly 只读修饰符，实例中不能修改该值，只读属性必须在声明时和构造函数里初始化</li></ul><h2 id="静态属性" tabindex="-1"><a class="header-anchor" href="#静态属性"><span>静态属性</span></a></h2><p>关键字static 可以通过类名直接调用</p><h2 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类"><span>抽象类</span></a></h2><p>抽象类一般不会去实例化对象，只能被类去实现，关键字abstract abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法</p>`,11)]))}const d=a(n,[["render",s],["__file","index.html.vue"]]),h=JSON.parse('{"path":"/tools/docs/interview/Ts/%E7%B1%BB/","title":"类","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"继承","slug":"继承","link":"#继承","children":[]},{"level":2,"title":"修饰符","slug":"修饰符","link":"#修饰符","children":[]},{"level":2,"title":"静态属性","slug":"静态属性","link":"#静态属性","children":[]},{"level":2,"title":"抽象类","slug":"抽象类","link":"#抽象类","children":[]}],"git":{"updatedTime":1738722167000,"contributors":[{"name":"LiHegui","username":"LiHegui","email":"1487647822@qq.com","commits":1,"url":"https://github.com/LiHegui"}]},"filePathRelative":"tools/docs/interview/Ts/类/index.md"}');export{d as comp,h as data};
