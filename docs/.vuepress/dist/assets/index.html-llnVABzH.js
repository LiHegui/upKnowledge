import{_ as i,c as l,a as o,o as t}from"./app-DPjPDnzl.js";const a={};function r(n,e){return t(),l("div",null,e[0]||(e[0]=[o('<h1 id="你是怎么理解es6中module的-使用场景" tabindex="-1"><a class="header-anchor" href="#你是怎么理解es6中module的-使用场景"><span>你是怎么理解ES6中Module的？使用场景？</span></a></h1><p>Module就是模块，是能够单独命名且独立完成一定功能的程序语言的集合。</p><ul><li>AMD 异步模块，采用异步的方式加载模块。所有的依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后 这个回调函数才能执行。 代表库require.js</li><li>CommonJS CommonJS是一套JavaScript模块规范，用于服务端。 <ul><li>模块是同步加载的，即只有加载完成，才能执行后面的操作</li><li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li><li>require返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值</li><li>所有代码都运行在模块作用域，不会污染全局作用域</li></ul></li><li>ES6 export 用于规定模块的外接接口。 import 用于输入其它模块提供的功能。 CommonJS和AMD都是在运行时才能确定需要加载什么，而ES6设计思想是静态化，想在编译阶段就确定模块的依赖关系，以及输入输出的变量。而且是按需加载，只加载所需要的。</li></ul><h2 id="es6的module使用" tabindex="-1"><a class="header-anchor" href="#es6的module使用"><span>ES6的module使用</span></a></h2>',4)]))}const d=i(a,[["render",r],["__file","index.html.vue"]]),m=JSON.parse('{"path":"/interview/ES6/Module/","title":"你是怎么理解ES6中Module的？使用场景？","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"ES6的module使用","slug":"es6的module使用","link":"#es6的module使用","children":[]}],"git":{"updatedTime":1738722167000,"contributors":[{"name":"LiHegui","username":"LiHegui","email":"1487647822@qq.com","commits":1,"url":"https://github.com/LiHegui"}]},"filePathRelative":"interview/ES6/Module/index.md"}');export{d as comp,m as data};
