import{_ as s,c as a,a as e,o as p}from"./app-DPjPDnzl.js";const l={};function t(i,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h1 id="vue-面试题" tabindex="-1"><a class="header-anchor" href="#vue-面试题"><span>Vue 面试题</span></a></h1><h2 id="有使用过vue吗-说说你对vue的理解" tabindex="-1"><a class="header-anchor" href="#有使用过vue吗-说说你对vue的理解"><span>有使用过vue吗？说说你对vue的理解</span></a></h2><p>Vue是一款构建用户界面的JavaScript框架</p><p>特点：</p><ul><li><p>MVVM 数据驱动 model 模型层，负责处理业务逻辑以及和服务器端进行交互 view 视图层， 负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面 v-model 视图模型层，用来连接Model和View，是Model和View之间的通信桥梁</p></li><li><p>组件化</p></li><li><p>指令系统</p><p><strong>如何实现自定义指令</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">    <span class="token comment">// 在 Vue 实例中注册全局自定义指令</span></span>
<span class="line">    Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">&#39;highlight&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 当绑定元素插入到 DOM 中时被调用</span></span>
<span class="line">        <span class="token function-variable function">inserted</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token string">&#39;yellow&#39;</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="你对spa单页面的理解-它的优缺点分别是什么-如何实现spa应用呢" tabindex="-1"><a class="header-anchor" href="#你对spa单页面的理解-它的优缺点分别是什么-如何实现spa应用呢"><span>你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢</span></a></h2><p><strong>如何实现一个SPA</strong></p><p>监听hash或者pushState变化 =&gt; 以当前的hash为索引，加载对应的资源 =&gt; 加载完成之后，隐藏之前的页面 =&gt;显示当前页面</p><p>路由分为两种模式</p><ul><li>hash模式 使用URL的锚点（Hash）来模拟整个页面的导航。例如：http://your-app/#/user #后面的内容后并不会导致页面刷新0</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Router</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>routes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>currentUrl <span class="token operator">=</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">;</span>  <span class="token comment">// 当页面加载或 URL 中的哈希值发生变化时，会触发 refresh 方法。在 refresh 方法中，会更新 currentUrl 属性的值，以便在后续的处理中可以使用当前的 URL。</span></span>
<span class="line"></span>
<span class="line">        window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;load&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>refresh<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将在页面加载时触发 refresh 方法，用于执行相应的回调函数</span></span>
<span class="line">        window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;hashchange&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>refresh<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 监听hash的变化</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token function">route</span><span class="token punctuation">(</span><span class="token parameter">path<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>routes<span class="token punctuation">[</span>path<span class="token punctuation">]</span> <span class="token operator">=</span> callback</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>routes<span class="token punctuation">[</span>path<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>routes<span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">window<span class="token punctuation">.</span>miniRouter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">miniRouter<span class="token punctuation">.</span><span class="token function">route</span><span class="token punctuation">(</span><span class="token string">&#39;/&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;page1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  </span>
<span class="line">miniRouter<span class="token punctuation">.</span><span class="token function">route</span><span class="token punctuation">(</span><span class="token string">&#39;/page2&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;page2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  </span>
<span class="line">  </span>
<span class="line">miniRouter<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&#39;/&#39;</span><span class="token punctuation">)</span> <span class="token comment">// page1  </span></span>
<span class="line">miniRouter<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&#39;/page2&#39;</span><span class="token punctuation">)</span> <span class="token comment">// page2  </span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>history history.pushState 浏览器历史纪录添加记录 history.replaceState修改浏览器历史纪录中当前纪录 history.popState 当 history 发生变化时触发 这些都不会让页面进行刷新</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="v-if和v-show的区别" tabindex="-1"><a class="header-anchor" href="#v-if和v-show的区别"><span>v-if和v-show的区别</span></a></h2><p>首先二者都是控制元素的显示与隐藏 v-show是利用css中的display:none;来做的，隐藏元素后，但是其dom元素依旧存在 v-if 是真实安装卸载元素，隐藏元素dom结构不存在，并且能触发元素的生命周期 使用场景</p><p>v-show用户切换状态比较频繁的场景，v-show初始渲染消耗性能比较大 v-if则是用于初始渲染</p><h2 id="vue实例挂载的过程" tabindex="-1"><a class="header-anchor" href="#vue实例挂载的过程"><span>Vue实例挂载的过程？</span></a></h2><p>template =&gt; AST =&gt; render函数 =&gt; 虚拟DOM =&gt; (patch,diffd) 真实DOM 新旧DOM树 =&gt; 流程</p><ol><li>init(options) 初始化 <ol><li>合并属性（判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法）</li><li>初始化的时候会创建组件实例、创建组件初始化状态、创建各种响应式数据</li></ol></li><li>在调用vm.$mount方法时 会将template 解析为 抽象语法树 (ast tree) 再将抽象语法树 转换成render语法字符串 最终生成render方法 挂载到vm上后，会再次调用mount方法</li><li>调用mountComponent渲染组件：此时会触发beforeMount钩子函数 ，定义updateComponent来渲染页面视图的方法，监听组件数据，一旦发生变化，触发beforeUpdate生命钩子 最后执行 callHook(vm, &#39;mounted&#39;) 钩子函数 完成挂载 updateComponent方法主要执行在vue初始化时声明的render，update方法</li></ol><p>挂载中最重要的两件事</p><ul><li>初始化</li><li>建立更新机制</li></ul><ol><li>挂载过程中指的是app.mount()过程，这是个初始化过程，整体做了两部分的工作：初始化和建立更新机制</li><li>此时会触发beforeMount钩子函数 ，定义updateComponent来渲染页面视图的方法，监听组件数据，一旦发生变化，触发beforeUpdate生命钩子 最后执行 callHook(vm, &#39;mounted&#39;) 钩子函数 完成挂载 updateComponent方法主要执行在vue初始化时声明的render，update方法</li></ol><p>1.确认挂载节点 2.编译模板为render函数 3.渲染函数转换为Virtual Dom 树 4.创建真实节点</p><h2 id="computed和watch的区别" tabindex="-1"><a class="header-anchor" href="#computed和watch的区别"><span>computed和Watch的区别</span></a></h2><p>computed和watch的区别？</p><p>computed 计算属性，根据组件的的数据返回新值，会存在依赖，同步执行</p><p>watch 监听，不会首次监听立即执行，除非设置immediate，数据发生更改，会触发回调函数， watch支持异步，还可以设置deep进行深度监听</p><p>总结关键词：用途|缓存|异步|返回值|首次监听 (1) computed(计算属性): 根据组件数据计算返回派生值 watch(监听属性): 监听数据, 执行回调函数(比如网络请求、dom操作) (2) computed能进行缓存，watch没有缓存 (3) computed有返回值，watch没有返回值 (4) computed不支持异步，watch支持异步 (5) computed第一次监听执行，watch不会第一次监听执行(除非设置immediate: true) (6) 此外watch还有属性deep可以进行深度监听</p><h3 id="watch-和-watcheffect-的区别" tabindex="-1"><a class="header-anchor" href="#watch-和-watcheffect-的区别"><span>watch 和 watchEffect 的区别？</span></a></h3><h2 id="请描述下你对vue生命周期的理解" tabindex="-1"><a class="header-anchor" href="#请描述下你对vue生命周期的理解"><span>请描述下你对vue生命周期的理解？</span></a></h2><ul><li>Vue2 创建-&gt;挂载-&gt;更新-&gt;销毁 <ul><li>beforeCreate 组件创建之初</li><li>Created 组将创建之后，此时页面结构还没好，data里面的数据已经可以用了</li><li>BeforeMounte 组件挂载之前</li><li>Mouted 组件挂载之后，此时页面结构都已存在</li><li>beforeUpdate 组件更新之前</li><li>Updated 组件更新之后</li><li>beforeDestory 组件销毁之前</li><li>destoryed 组件销毁之后</li><li>activated keep-live组件激活时触发</li><li>deactivated keep-alive 缓存的组件停用时调用</li></ul></li><li>Vue3 <ul><li>onBeforeMount – 在挂载开始之前被调用：相关的 render 函数首次被调用。</li><li>onMounted – 组件挂载时调用</li><li>onBeforeUpdate – 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</li><li>onUpdated – 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</li><li>onBeforeUnmount – 在卸载组件实例之前调用。在这个阶段，实例仍然是完全正常的。</li><li>onUnmounted – 卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。</li><li>onActivated – 被 keep-alive 缓存的组件激活时调用。</li><li>onDeactivated – 被 keep-alive 缓存的组件停用时调用。</li><li>onErrorCaptured – 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</li></ul></li></ul><h3 id="父子组件发生更新-生命周期的情况" tabindex="-1"><a class="header-anchor" href="#父子组件发生更新-生命周期的情况"><span>父子组件发生更新，生命周期的情况</span></a></h3><p>一句话 自上而下的创建 自下而上的挂载</p><p>父组件的beforeUpdate钩子函数被调用。 子组件的beforeUpdate钩子函数被调用。 子组件的updated钩子函数被调用。 父组件的updated钩子函数被调用。</p><h3 id="父子组件初始渲染的时生命周期执行情况" tabindex="-1"><a class="header-anchor" href="#父子组件初始渲染的时生命周期执行情况"><span>父子组件初始渲染的时生命周期执行情况</span></a></h3><p>父组件的beforeCreate钩子函数被调用。 父组件的created钩子函数被调用。 父组件的beforeMount钩子函数被调用。 子组件的beforeCreate钩子函数被调用。 子组件的created钩子函数被调用。 子组件的beforeMount钩子函数被调用。 子组件的mounted钩子函数被调用。 父组件的mounted钩子函数被调用。 在这个过程中，父组件首先被创建并挂载，然后子组件被创建并挂载。在每个组件的生命周期函数中，可以进行一些初始化操作，例如获取数据或准备组件的状态。 需要注意的是，在组件渲染之前，beforeCreate和created钩子函数被调用，而在组件渲染之后，beforeMount和mounted钩子函数被调用。在这些钩子函数中，可以执行一些在组件渲染之前或之后需要进行的操作。 另外，在每个组件的destroyed钩子函数中，可以执行一些在组件被销毁时需要进行的操作，例如清理定时器或取消事件监听器。</p><h3 id="异步生命周期" tabindex="-1"><a class="header-anchor" href="#异步生命周期"><span>异步生命周期</span></a></h3><p>async created</p><p>async mounted</p><h2 id="keep-live组件" tabindex="-1"><a class="header-anchor" href="#keep-live组件"><span>keep-live组件</span></a></h2><p>keep-alive 是 Vue.js 内置的一个抽象组件，用于缓存具有相同组件标签 component 的组件实例，以避免在组件切换时频繁地销毁和重新创建组件实例，从而提高应用程序的性能。</p><p>组件切换过程中，将状态保留再内存中，防止重复污染</p><p>直接包裹</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token operator">&lt;</span>keep<span class="token operator">-</span>live<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token operator">...</span>Element</span>
<span class="line"><span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>live<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="v-if和v-for的优先级是什么" tabindex="-1"><a class="header-anchor" href="#v-if和v-for的优先级是什么"><span>v-if和v-for的优先级是什么？</span></a></h2><p>v-if 是控制元素显示与隐藏 v-for 是遍历组件 v-if和v-for作用于同一组件 Vue2中v-for的优先级更高 Vue3中v-if优先级更高</p><h2 id="为什么data属性是一个函数而不是一个对象" tabindex="-1"><a class="header-anchor" href="#为什么data属性是一个函数而不是一个对象"><span>为什么data属性是一个函数而不是一个对象？</span></a></h2><p>在Vue中，data属性可以是对象或者函数</p><p>当data属性为一个对象时，这个对象会被组件实例共享（同个组件被多次引用），因为引用的都是同一个对象地址，这可能会导致不同组件之间的数据相互影响，从而引起一些难以调试的东西。</p><p>当data属性为一个函数时，通过函数return出来的对象，都是一个全新的数据对象，每个组件都拥有独立的数据对象，不会相互影响。</p><h2 id="动态给vue的data添加一个新的属性时会发生什么-怎样解决" tabindex="-1"><a class="header-anchor" href="#动态给vue的data添加一个新的属性时会发生什么-怎样解决"><span>动态给vue的data添加一个新的属性时会发生什么？怎样解决？</span></a></h2><p>动态的给data添加一个新的属性，并不会触发数据的响应式操作，也就是或新加入的属性改变时，不会触发响应式，不会触发页面刷新。</p><p>Vue2中是使用Object.defineProperty()去实现的，Vue在初始化的时候会进行这个操作，数据中的每个属性的时候触发get或set操作中触发相关依赖，才会导致视图更新</p><p>也就是说你可以使用强制刷新方法。</p><ul><li>Vue.$set(),向响应式对象中添加一个property,并确保这个新的peoperty也是响应式的且触发视图刷新。<div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">    Vue<span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>someObj<span class="token punctuation">,</span>perporty<span class="token punctuation">,</span>newPerportyValue<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li>Object.assign() 进行合并对象 混入原有的对象<div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>someObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>someObj<span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token literal-property property">newProperty</span><span class="token operator">:</span>newPropertyValue<span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h2 id="vue中组件和插件有什么区别" tabindex="-1"><a class="header-anchor" href="#vue中组件和插件有什么区别"><span>Vue中组件和插件有什么区别？</span></a></h2><p>在Vue中，组件和插件都是可重用的代码模块，但它们有一些区别。</p><ul><li>组件 组件是Vue中的基本概念，它是一个可重用的Vue实例，用于封装可复用的HTML元素和相关的JavaScript代码和CSS样式。组件可以拥有自己的状态和生命周期钩子，可以接收父组件传递的数据，也可以向父组件发送事件。 组件通常用于封装具有某种特定功能的UI元素，例如按钮、表单、对话框等。组件可以在应用程序的不同部分中重复使用，从而提高了代码的复用性和可维护性。</li><li>插件 插件是Vue的扩展机制，通过为Vue添加全局功能或功能库，来扩展Vue的能力。插件通常会为Vue添加全局的方法、指令、过滤器、组件等，或者添加全局的功能库，例如路由器、状态管理器等。 插件通常是通过Vue的Vue.use()方法安装到Vue中的。在安装插件时，我们可以为插件传递一些参数或选项，从而定制插件的行为。 需要注意的是，插件通常是全局的，它们会影响到整个Vue应用程序，因此在使用插件时需要谨慎，避免产生不必要的影响和冲突。一般来说，只有在需要全局添加某些功能或库时，才需要使用插件。</li></ul><h2 id="vue组件之间的通信方式都有哪些" tabindex="-1"><a class="header-anchor" href="#vue组件之间的通信方式都有哪些"><span>Vue组件之间的通信方式都有哪些？</span></a></h2><ul><li><p>父子组件通信 父组件通过props传递参数给子组件 子组件通过emit事件，传递数据给父组件 父组件可以$children来获取子组件的数据以及调用其函数 子组件也可以通过$parent来获取父组件的数据以及调用函数</p></li><li><p>爷孙组件通信 vue中还提供了inject和provide两个选项，可以用于爷孙组件之间的数据传递。这种方式与向下传递prop和向上触发事件的方式不同，它提供了一种在父组件和子孙组件之间建立依赖关系的方式，从而实现跨层级的数据传递。 具体来说，爷组件可以通过provide选项提供数据，然后孙组件可以通过inject选项注入该数据。这样，孙组件就可以在不需要显式的prop和事件传递的情况下，访问爷组件提供的数据。 Grandparent.vue</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">    <span class="token operator">&lt;</span>template<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span></span>
<span class="line">        <span class="token operator">&lt;</span>parent<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>parent<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span></span>
<span class="line"></span>
<span class="line">    <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token keyword">import</span> Parent <span class="token keyword">from</span> <span class="token string">&#39;./Parent.vue&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">        Parent</span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token literal-property property">provide</span><span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">&#39;Hello from Grandparent&#39;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>通过Vuex进行通信 vuex详解：</p></li><li><p>通过浏览器存储</p></li><li><p>通过事件总线或订阅发布进行通信</p></li></ul><h2 id="vue响应式原理" tabindex="-1"><a class="header-anchor" href="#vue响应式原理"><span>Vue响应式原理</span></a></h2><p>数据劫持+订阅发布 Dep reactive watchEffect Dep负责订阅发布功能 Vue2的响应式是基于Object.defineProperty实现的 Vue3的响应式是基于ES6的Proxy来实现的 弊端就是：Object.defineProperty只对初始对象里的属性有监听作用，而对新增的属性无效。这也是为什么Vue2中对象新增属性的修 改需要使用Vue.$set来设值的原因。</p><h2 id="双向数据绑定是什么" tabindex="-1"><a class="header-anchor" href="#双向数据绑定是什么"><span>双向数据绑定是什么？</span></a></h2><p>Vue是MVVM M VM V</p><h2 id="vue中的-nexttick有什么作用" tabindex="-1"><a class="header-anchor" href="#vue中的-nexttick有什么作用"><span>Vue中的$nextTick有什么作用？</span></a></h2><p>Vue的响应式不是发生数据后立即变化的，而是按照一定的策略进行DOM更新，这样的好处是可以避免一些不必要的操作，提高渲染性能。 在Vue官方文档中是这样说明的：</p><p>Vue异步执行DOM更新。只要观察到数据变化，Vue将开启一个队列， 并缓冲在同一事件循环中发生的所有数据改变。</p><p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作上非常重要。 然后，在下一个的事件循环“tick”中，Vue刷新队列并执行实际 (已去重的) 工作。 总之就是放在nextTick中的操作会再DOM更新之后执行 使用:作为参数的函数会进入异步任务中的异步任务队列中</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">    this.$nextTick(()=&gt;{</span>
<span class="line"></span>
<span class="line">    })</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用场景：</p><ol><li>在Created里面想要获取DOM操作。</li><li>响应式数据变化之后，想要获取最新的DOM结构</li><li></li></ol><h2 id="说说你对vue的mixin的理解-有什么应用场景" tabindex="-1"><a class="header-anchor" href="#说说你对vue的mixin的理解-有什么应用场景"><span>说说你对vue的mixin的理解，有什么应用场景？</span></a></h2><p>mixin就是混入，就是把一些可复用的功能分发下去。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">    // src/mixin/index.js</span>
<span class="line">    export const mixins = {</span>
<span class="line">    data() {</span>
<span class="line">        return {};</span>
<span class="line">    },</span>
<span class="line">    computed: {},</span>
<span class="line">    created() {},</span>
<span class="line">    mounted() {},</span>
<span class="line">    methods: {},</span>
<span class="line">    };</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>选项合并 相同类型（如生命周期），先执行mixin混入的代码，再执行组件本身的代码 组件数据冲突，组件本身的数据会覆盖minxin中data的相同属性名的数据 方法冲突也是如此</li><li>优缺点 提高代码复用性、无需传递状态、维护方便 命名冲突、滥用的话难以维护、不好溯源</li></ul><h2 id="说说你对slot的理解-slot使用场景有哪些" tabindex="-1"><a class="header-anchor" href="#说说你对slot的理解-slot使用场景有哪些"><span>说说你对slot的理解？slot使用场景有哪些？</span></a></h2><ul><li>介绍：它是vue中一种非常重要的机制，主要用于父组件向子组件传递内容的一种方式</li><li>使用：在子组件中定义一些具有特定意义的slot插槽用来占位，父组件在使用子组件的时候，通过插入内容来覆盖子组件中的这些插槽，实现组件的高灵活性</li><li>类型 <ol><li>默认插槽</li><li>具名插槽</li><li>作用于插槽</li></ol></li><li>使用场景： <ul><li>插入自定义内容：静态内容和动态内容</li><li>插入组件：按钮、弹窗、提示框</li><li>复杂组件的拆分</li></ul></li></ul><h2 id="vue-observable你有了解过吗-说说看" tabindex="-1"><a class="header-anchor" href="#vue-observable你有了解过吗-说说看"><span>Vue.observable你有了解过吗？说说看</span></a></h2><h2 id="说说你对keep-alive的理解是什么" tabindex="-1"><a class="header-anchor" href="#说说你对keep-alive的理解是什么"><span>说说你对keep-alive的理解是什么？</span></a></h2><ul><li>介绍：它是vue中的内置组件，能够在组件切换的过程中将状态保留在内存中，防止重复渲染dom，实质是缓存组件实例，不进行销毁</li><li>生命周期：使用keep-alive包裹的组件，会多出两个生命周期钩子activated和deactivated</li><li>可以设置的props属性：include=&gt;名称匹配的组件才会被缓存；exclude=&gt;名称匹配的组件不会被缓存；max=&gt;组件的最大缓存数量</li><li>使用场景： <ul><li>频繁使用的路由</li><li>频繁使用的组件</li><li>带有状态的组件</li></ul></li></ul><h2 id="vue常用的修饰符有哪些有什么应用场景" tabindex="-1"><a class="header-anchor" href="#vue常用的修饰符有哪些有什么应用场景"><span>Vue常用的修饰符有哪些有什么应用场景</span></a></h2><ul><li>表单 <ol><li>lazy：当光标离开时触发同步</li><li>trim：自动过滤用户输入字符的前置空格</li><li>number：将输入的数据转换成数值类型</li></ol></li><li>事件 <ol><li>stop:阻止事件冒泡</li><li>prevent：阻止事件默认行为</li><li>self：只在自身触发事件</li><li>once：只触发一次事件</li><li>caption：从顶层开始往下触发事件</li><li>passive：监听鼠标滚动</li><li>native：监听原生事件</li></ol></li><li>鼠标 <ul><li>left</li><li>right</li><li>middle</li></ul></li><li>键盘</li><li>v-bing <ol><li>async</li><li>prop</li><li>camel</li></ol></li></ul><h2 id="你有写过自定义指令吗-自定义指令的应用场景有哪些" tabindex="-1"><a class="header-anchor" href="#你有写过自定义指令吗-自定义指令的应用场景有哪些"><span>你有写过自定义指令吗？自定义指令的应用场景有哪些？</span></a></h2><ul><li>介绍：vue中提供了很多数据驱动视图更加方便的操作，这些操作也被称为指令。我们常见的v-开头的行内属性就是指令，不同指令完成不同的功能</li><li>如何实现： <ul><li>全局注册：通过Vue.directive（）方法注册：第一个参数的指令名称，第二个参数是一个数据对象，也可以是一个指令函数</li><li>局部注册：就是在组件的options选项中设置directive属性，参数类型和全局注册一样</li></ul></li><li>常见场景： <ul><li>输入框自动聚焦</li><li>表单限制输入</li><li>图片懒加载</li><li>滚动加载</li><li>绑定节流</li></ul></li></ul><h2 id="vue中的过滤器了解吗-过滤器的应用场景有哪些" tabindex="-1"><a class="header-anchor" href="#vue中的过滤器了解吗-过滤器的应用场景有哪些"><span>Vue中的过滤器了解吗？过滤器的应用场景有哪些？</span></a></h2><h2 id="什么是虚拟dom-如何实现一个虚拟dom-说说你的思路" tabindex="-1"><a class="header-anchor" href="#什么是虚拟dom-如何实现一个虚拟dom-说说你的思路"><span>什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路</span></a></h2><p><a href="https://juejin.cn/post/7173809965772046350#heading-13" target="_blank" rel="noopener noreferrer">参考文章</a></p><p>虚拟DOM本身是JavaScript对象模拟dom对象，通过不同的属性去描述视图结构</p><ol><li>目的是减少操作真实DOM的次数，提高性能</li></ol><p>前端性能优化一个重要的方向就是尽可能少的减少操作DOM,不仅仅是DOM相对比较慢。因为频繁的变动DOM会造成 浏览器的回流与重绘。</p><p>vDom如何形成 compile编译 template(-&gt; AST -&gt;) =&gt; render Function =&gt; VNode(虚拟DOM) =&gt;（patch过程）真实DOM</p><p>vnode</p><ul><li>tag</li><li>attrs</li><li>childred</li></ul><ol start="2"><li>方便跨平台</li></ol><p>同一vnode节点可以渲染成不同平台上对应的内容</p><h2 id="用js对象来描述dom" tabindex="-1"><a class="header-anchor" href="#用js对象来描述dom"><span>用JS对象来描述DOM</span></a></h2><h2 id="虚拟dom更新视图流程" tabindex="-1"><a class="header-anchor" href="#虚拟dom更新视图流程"><span>虚拟DOM更新视图流程</span></a></h2><p>用JavaScript对象来表示真实的DOM,DOM与DOM节点之间形成一个DOM树 数据发生改变，需要更新视图，会采用diff算法比较新旧DOM树 最终只会更新差异的部分在真实的DOM树上</p><p>我们在Vue中尝尝写一些模板template =&gt; ast =&gt; render()形成虚拟DOM =&gt;真实DOM 数据发生改变时，需要必将这一次与上一次的渲染结果，也就是比较两次的虚拟DOM树 比较过程： patch是一个递归过程、深度优先、同层比较的策略</p><ul><li>新旧节点进行比较是否相同，相同就就行下一步，不相同就进行节点的替换或者插入操作</li><li>对相同节点的属性进行判断，如果属性发生变化，就进行更新</li><li>对子节点进行递归比较，如果子节点有变化就进行更新或者删除</li><li>对旧节点剩余的节点进行删除操作</li></ul><h2 id="你了解vue的diff算法吗-说说看" tabindex="-1"><a class="header-anchor" href="#你了解vue的diff算法吗-说说看"><span>你了解vue的diff算法吗？说说看</span></a></h2><p>Vue Diff算法 组件内响应式数据发生变更触发实例执行其更新函数、更新函数会再次执行render函数获取最新的虚拟DOM 然后执行patch函数，并传入两次的虚拟DOM, 通过Diff算法比较二者变化的地方、最后将其转化为真实DOM</p><h3 id="diff算法的优化" tabindex="-1"><a class="header-anchor" href="#diff算法的优化"><span>diff算法的优化</span></a></h3><ul><li>避免使用index作为唯一的key，尽可能使用具有唯一性的标识符作为key</li><li>尽可能减少dom的嵌套层级和节点的数量，较少diff算法的计算</li><li>尽量减少频繁增删节点，适当使用vshow和vif控制节点的显示和隐藏</li></ul><p><strong>Diff 算法的核心思想是Diff就是将新老虚拟DOM的不同点找到并生成一个补丁，并根据这个补丁生成更新操作，以最小化对实际 DOM 的操作，提高页面渲染的性能和效率</strong></p><h2 id="你知道vue中key的原理吗-说说你对它的理解" tabindex="-1"><a class="header-anchor" href="#你知道vue中key的原理吗-说说你对它的理解"><span>你知道vue中key的原理吗？说说你对它的理解</span></a></h2><p>在Vue中，key是用来帮助Vue识别节点的优化手段，v-for或者diff算法中同层比较的时候，都是会利用key 来比较新旧元素，尽可能复用已有的元素。 key是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点</p><h2 id="vue项目中有封装过axios吗-主要是封装哪方面的" tabindex="-1"><a class="header-anchor" href="#vue项目中有封装过axios吗-主要是封装哪方面的"><span>Vue项目中有封装过axios吗？主要是封装哪方面的？</span></a></h2><h2 id="你了解axios的原理吗-有看过它的源码吗" tabindex="-1"><a class="header-anchor" href="#你了解axios的原理吗-有看过它的源码吗"><span>你了解axios的原理吗？有看过它的源码吗？</span></a></h2><h2 id="ssr解决了什么问题-有做过ssr吗-你是怎么做的" tabindex="-1"><a class="header-anchor" href="#ssr解决了什么问题-有做过ssr吗-你是怎么做的"><span>SSR解决了什么问题？有做过SSR吗？你是怎么做的？</span></a></h2><h2 id="说下你的vue项目的目录结构-如果是大型项目你该怎么划分结构和划分组件呢" tabindex="-1"><a class="header-anchor" href="#说下你的vue项目的目录结构-如果是大型项目你该怎么划分结构和划分组件呢"><span>说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？</span></a></h2><h2 id="vue要做权限管理该怎么做-如果控制到按钮级别的权限怎么做" tabindex="-1"><a class="header-anchor" href="#vue要做权限管理该怎么做-如果控制到按钮级别的权限怎么做"><span>vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？</span></a></h2><h2 id="vue项目中你是如何解决跨域的呢" tabindex="-1"><a class="header-anchor" href="#vue项目中你是如何解决跨域的呢"><span>Vue项目中你是如何解决跨域的呢？</span></a></h2><p>跨域的本质是浏览器基于同源策略的一种安全手段</p><p>同源策略是指</p><ul><li>协议相同</li><li>主机相同</li><li>端口相同</li></ul><p><strong>跨域的解决办法</strong></p><ol><li>jsonp 但是只能处理get请求</li><li>CROS CROS是一个系统，它是由一系列传输的HTTP头组成的，这些HTTP请求头决定浏览器是否阻止前端JavaScript代码获取跨域请求的响应 也就是让后端实现跨域</li><li>代理 webpack会起一个本地服务器进行请求代理转发<div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">     module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">         <span class="token literal-property property">devServer</span><span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">             <span class="token literal-property property">host</span><span class="token operator">:</span> <span class="token string">&#39;127.0.0.1&#39;</span><span class="token punctuation">,</span></span>
<span class="line">             <span class="token literal-property property">port</span><span class="token operator">:</span> <span class="token number">8084</span><span class="token punctuation">,</span></span>
<span class="line">             <span class="token literal-property property">open</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment">// vue项目启动时自动打开浏览器</span></span>
<span class="line">             <span class="token literal-property property">proxy</span><span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">                 <span class="token string-property property">&#39;/api&#39;</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// &#39;/api&#39;是代理标识，用于告诉node，url前面是/api的就是使用代理的</span></span>
<span class="line">                     <span class="token literal-property property">target</span><span class="token operator">:</span> <span class="token string">&quot;http://xxx.xxx.xx.xx:8080&quot;</span><span class="token punctuation">,</span> <span class="token comment">//目标地址，一般是指后台服务器地址</span></span>
<span class="line">                     <span class="token literal-property property">changeOrigin</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//是否跨域</span></span>
<span class="line">                     <span class="token literal-property property">pathRewrite</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// pathRewrite 的作用是把实际Request Url中的&#39;/api&#39;用&quot;&quot;代替</span></span>
<span class="line">                         <span class="token string-property property">&#39;^/api&#39;</span><span class="token operator">:</span> <span class="token string">&quot;&quot;</span> </span>
<span class="line">                     <span class="token punctuation">}</span></span>
<span class="line">                 <span class="token punctuation">}</span></span>
<span class="line">             <span class="token punctuation">}</span></span>
<span class="line">         <span class="token punctuation">}</span></span>
<span class="line">     <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>服务端进行请求转发<div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">    <span class="token keyword">var</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;express&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;http-proxy-middleware&#39;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token function">static</span><span class="token punctuation">(</span>__dirname <span class="token operator">+</span> <span class="token string">&#39;/&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">&#39;/api&#39;</span><span class="token punctuation">,</span> <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">target</span><span class="token operator">:</span> <span class="token string">&#39;http://localhost:4000&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">changeOrigin</span><span class="token operator">:</span> <span class="token boolean">false</span></span>
<span class="line">                        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    module<span class="token punctuation">.</span>exports <span class="token operator">=</span> app</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>nginx实现代理<div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">    server <span class="token punctuation">{</span></span>
<span class="line">    listen    <span class="token number">80</span><span class="token punctuation">;</span></span>
<span class="line">    # server_name www<span class="token punctuation">.</span>josephxia<span class="token punctuation">.</span>com<span class="token punctuation">;</span></span>
<span class="line">    location <span class="token operator">/</span> <span class="token punctuation">{</span></span>
<span class="line">        root  <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>www<span class="token operator">/</span>html<span class="token punctuation">;</span></span>
<span class="line">        index  index<span class="token punctuation">.</span>html index<span class="token punctuation">.</span>htm<span class="token punctuation">;</span></span>
<span class="line">        try_files $uri $uri<span class="token operator">/</span> <span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    location <span class="token operator">/</span>api <span class="token punctuation">{</span></span>
<span class="line">        proxy_pass  http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">3000</span><span class="token punctuation">;</span></span>
<span class="line">        proxy_redirect   off<span class="token punctuation">;</span></span>
<span class="line">        proxy_set_header  Host       $host<span class="token punctuation">;</span></span>
<span class="line">        proxy_set_header  <span class="token constant">X</span><span class="token operator">-</span>Real<span class="token operator">-</span><span class="token constant">IP</span>     $remote_addr<span class="token punctuation">;</span></span>
<span class="line">        proxy_set_header  <span class="token constant">X</span><span class="token operator">-</span>Forwarded<span class="token operator">-</span>For  $proxy_add_x_forwarded_for<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="vue项目本地开发完成后部署到服务器后报404是什么原因呢" tabindex="-1"><a class="header-anchor" href="#vue项目本地开发完成后部署到服务器后报404是什么原因呢"><span>vue项目本地开发完成后部署到服务器后报404是什么原因呢？</span></a></h2><h2 id="你是怎么处理vue项目中的错误的" tabindex="-1"><a class="header-anchor" href="#你是怎么处理vue项目中的错误的"><span>你是怎么处理vue项目中的错误的？</span></a></h2><h2 id="vue3有了解过吗-能说说跟vue2的区别吗-新特性" tabindex="-1"><a class="header-anchor" href="#vue3有了解过吗-能说说跟vue2的区别吗-新特性"><span>vue3有了解过吗？能说说跟vue2的区别吗(新特性)？</span></a></h2><ol><li><p>composition API</p></li><li><p>SFC ComPosition API 语法糖</p></li></ol><p>框架层面</p><ol><li>基于Proxy的响应式系统</li><li></li></ol><h2 id="选项式api与组合式api" tabindex="-1"><a class="header-anchor" href="#选项式api与组合式api"><span>选项式API与组合式API</span></a></h2><h2 id="ref和reactive" tabindex="-1"><a class="header-anchor" href="#ref和reactive"><span>ref和reactive</span></a></h2><pre><code>- 作用
- 源码实现
    - ref
        
    - reactive
</code></pre><h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期"><span>生命周期</span></a></h2><h2 id="watch和computed" tabindex="-1"><a class="header-anchor" href="#watch和computed"><span>watch和computed</span></a></h2><h2 id="组件通信" tabindex="-1"><a class="header-anchor" href="#组件通信"><span>组件通信</span></a></h2><ul><li>父子通信 props、emit、ref、$parent</li><li>兄弟组件通信 事件总线、第三方</li><li>边界知识： provide/inject/$attrs</li><li>VueX、浏览器存储（共享信息）</li></ul><p><strong>关于provide注意</strong></p><p>provide的第二个参数作为导出的值可以是任意参数(非相响应式或响应式) provide只能够向下进行传递数据 在使用provide和inject的时候需从vue中引入</p><h2 id="路由" tabindex="-1"><a class="header-anchor" href="#路由"><span>路由</span></a></h2><h2 id="快速上手vuex-到-手写简易-vuex" tabindex="-1"><a class="header-anchor" href="#快速上手vuex-到-手写简易-vuex"><span>快速上手Vuex 到 手写简易 Vuex</span></a></h2><p>使用VueX的好处</p><ul><li><p>能够在VueX集中管理数据，易于开发和后期维护</p></li><li><p>能够高效地实现组件之间的数据共享，提高开发效率</p></li><li><p>在 vuex 中的数据都是响应式的 VueX的基础使用</p></li><li><p>state 存放数据 取state两种方式:</p><ul><li>方式一</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">    this.$store.state.perportyName</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>方式二</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">    ...mapState([perpoetyName1,perportyName2])</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>mutation Store 中的状态不能直接对其进行操作，我们得使用 Mutation 来对 Store 中的状态进行修改，虽然看起来有些繁琐，但是方便集中监控数据的变化 state的更新必须是Mutation来处理 两种触发方式</p><ul><li>方式一<div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">    this.$store.commit(funName)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li>方式二<div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">    ...mapMutations([funName1,funName2])</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li><li><p>action 异步调用的方式 action =&gt; mutation =&gt; state 调用方式</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">    this.$store.dispatch()</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>方式二</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">    mapAction([actionFun1,actionFun2])</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>getter Getter类似于计算属性，但是我们的数据来源是state</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">    <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&#39;xxx&#39;</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token literal-property property">getter</span><span class="token operator">:</span><span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">// state作为第一个参数，可调用上面的state里面的数据</span></span>
<span class="line">            <span class="token function">myname</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">return</span> <span class="token string">&quot;我的名字是&quot;</span><span class="token operator">+</span>state<span class="token punctuation">.</span>name</span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>组件引入方式</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>myname</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>第二种</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">    <span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;myname&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>module state数据过多时，就会变得难以管理，VueX允许将store分成不同的模块，每个模块都有属于自己的state等</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">const</span> getter <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span></span>
<span class="line">        state<span class="token punctuation">,</span></span>
<span class="line">        mutations<span class="token punctuation">,</span></span>
<span class="line">        actions<span class="token punctuation">,</span></span>
<span class="line">        getter</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>index.js</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">    <span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">&#39;./Home&#39;</span></span>
<span class="line">    <span class="token keyword">import</span> Search <span class="token keyword">from</span> <span class="token string">&#39;./Search&#39;</span></span>
<span class="line">    <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token literal-property property">actions</span><span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token literal-property property">modules</span><span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">        Home<span class="token punctuation">,</span>      <span class="token comment">//</span></span>
<span class="line">        Search</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="vue性能优化" tabindex="-1"><a class="header-anchor" href="#vue性能优化"><span>Vue性能优化</span></a></h2><h2 id="vue-从template到render发生了什么" tabindex="-1"><a class="header-anchor" href="#vue-从template到render发生了什么"><span>Vue 从template到render发生了什么？</span></a></h2><p>Vue中有个编译模块=&gt; &#39;compiler&#39;, 它的主要作用就是将template编译为js中可执行的render函数</p><p>Vue编辑器会对template先进行解析，这一步成为parse, 结束之后会得到一个JS对象，我们成为抽象语法树AST，然后是对AST进行深加工的转换过程，然后是对AST进行深加工的转换过程，这一步成为transform,最后将得到的AST生成为JS代码，也就是render函数</p><h2 id="v-model原理" tabindex="-1"><a class="header-anchor" href="#v-model原理"><span>v-model原理</span></a></h2><p>v-model是语法糖，用来监听用户事件以更新数据，绑定组件里面的数据</p><p>如果绑定一个不存在的属性，vue会加上这个响应式</p><p>双向绑定</p>`,145)]))}const c=s(l,[["render",t],["__file","vue.html.vue"]]),r=JSON.parse('{"path":"/interview/Vue/vue.html","title":"Vue 面试题","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"有使用过vue吗？说说你对vue的理解","slug":"有使用过vue吗-说说你对vue的理解","link":"#有使用过vue吗-说说你对vue的理解","children":[]},{"level":2,"title":"你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢","slug":"你对spa单页面的理解-它的优缺点分别是什么-如何实现spa应用呢","link":"#你对spa单页面的理解-它的优缺点分别是什么-如何实现spa应用呢","children":[]},{"level":2,"title":"v-if和v-show的区别","slug":"v-if和v-show的区别","link":"#v-if和v-show的区别","children":[]},{"level":2,"title":"Vue实例挂载的过程？","slug":"vue实例挂载的过程","link":"#vue实例挂载的过程","children":[]},{"level":2,"title":"computed和Watch的区别","slug":"computed和watch的区别","link":"#computed和watch的区别","children":[{"level":3,"title":"watch 和 watchEffect 的区别？","slug":"watch-和-watcheffect-的区别","link":"#watch-和-watcheffect-的区别","children":[]}]},{"level":2,"title":"请描述下你对vue生命周期的理解？","slug":"请描述下你对vue生命周期的理解","link":"#请描述下你对vue生命周期的理解","children":[{"level":3,"title":"父子组件发生更新，生命周期的情况","slug":"父子组件发生更新-生命周期的情况","link":"#父子组件发生更新-生命周期的情况","children":[]},{"level":3,"title":"父子组件初始渲染的时生命周期执行情况","slug":"父子组件初始渲染的时生命周期执行情况","link":"#父子组件初始渲染的时生命周期执行情况","children":[]},{"level":3,"title":"异步生命周期","slug":"异步生命周期","link":"#异步生命周期","children":[]}]},{"level":2,"title":"keep-live组件","slug":"keep-live组件","link":"#keep-live组件","children":[]},{"level":2,"title":"v-if和v-for的优先级是什么？","slug":"v-if和v-for的优先级是什么","link":"#v-if和v-for的优先级是什么","children":[]},{"level":2,"title":"为什么data属性是一个函数而不是一个对象？","slug":"为什么data属性是一个函数而不是一个对象","link":"#为什么data属性是一个函数而不是一个对象","children":[]},{"level":2,"title":"动态给vue的data添加一个新的属性时会发生什么？怎样解决？","slug":"动态给vue的data添加一个新的属性时会发生什么-怎样解决","link":"#动态给vue的data添加一个新的属性时会发生什么-怎样解决","children":[]},{"level":2,"title":"Vue中组件和插件有什么区别？","slug":"vue中组件和插件有什么区别","link":"#vue中组件和插件有什么区别","children":[]},{"level":2,"title":"Vue组件之间的通信方式都有哪些？","slug":"vue组件之间的通信方式都有哪些","link":"#vue组件之间的通信方式都有哪些","children":[]},{"level":2,"title":"Vue响应式原理","slug":"vue响应式原理","link":"#vue响应式原理","children":[]},{"level":2,"title":"双向数据绑定是什么？","slug":"双向数据绑定是什么","link":"#双向数据绑定是什么","children":[]},{"level":2,"title":"Vue中的$nextTick有什么作用？","slug":"vue中的-nexttick有什么作用","link":"#vue中的-nexttick有什么作用","children":[]},{"level":2,"title":"说说你对vue的mixin的理解，有什么应用场景？","slug":"说说你对vue的mixin的理解-有什么应用场景","link":"#说说你对vue的mixin的理解-有什么应用场景","children":[]},{"level":2,"title":"说说你对slot的理解？slot使用场景有哪些？","slug":"说说你对slot的理解-slot使用场景有哪些","link":"#说说你对slot的理解-slot使用场景有哪些","children":[]},{"level":2,"title":"Vue.observable你有了解过吗？说说看","slug":"vue-observable你有了解过吗-说说看","link":"#vue-observable你有了解过吗-说说看","children":[]},{"level":2,"title":"说说你对keep-alive的理解是什么？","slug":"说说你对keep-alive的理解是什么","link":"#说说你对keep-alive的理解是什么","children":[]},{"level":2,"title":"Vue常用的修饰符有哪些有什么应用场景","slug":"vue常用的修饰符有哪些有什么应用场景","link":"#vue常用的修饰符有哪些有什么应用场景","children":[]},{"level":2,"title":"你有写过自定义指令吗？自定义指令的应用场景有哪些？","slug":"你有写过自定义指令吗-自定义指令的应用场景有哪些","link":"#你有写过自定义指令吗-自定义指令的应用场景有哪些","children":[]},{"level":2,"title":"Vue中的过滤器了解吗？过滤器的应用场景有哪些？","slug":"vue中的过滤器了解吗-过滤器的应用场景有哪些","link":"#vue中的过滤器了解吗-过滤器的应用场景有哪些","children":[]},{"level":2,"title":"什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路","slug":"什么是虚拟dom-如何实现一个虚拟dom-说说你的思路","link":"#什么是虚拟dom-如何实现一个虚拟dom-说说你的思路","children":[]},{"level":2,"title":"用JS对象来描述DOM","slug":"用js对象来描述dom","link":"#用js对象来描述dom","children":[]},{"level":2,"title":"虚拟DOM更新视图流程","slug":"虚拟dom更新视图流程","link":"#虚拟dom更新视图流程","children":[]},{"level":2,"title":"你了解vue的diff算法吗？说说看","slug":"你了解vue的diff算法吗-说说看","link":"#你了解vue的diff算法吗-说说看","children":[{"level":3,"title":"diff算法的优化","slug":"diff算法的优化","link":"#diff算法的优化","children":[]}]},{"level":2,"title":"你知道vue中key的原理吗？说说你对它的理解","slug":"你知道vue中key的原理吗-说说你对它的理解","link":"#你知道vue中key的原理吗-说说你对它的理解","children":[]},{"level":2,"title":"Vue项目中有封装过axios吗？主要是封装哪方面的？","slug":"vue项目中有封装过axios吗-主要是封装哪方面的","link":"#vue项目中有封装过axios吗-主要是封装哪方面的","children":[]},{"level":2,"title":"你了解axios的原理吗？有看过它的源码吗？","slug":"你了解axios的原理吗-有看过它的源码吗","link":"#你了解axios的原理吗-有看过它的源码吗","children":[]},{"level":2,"title":"SSR解决了什么问题？有做过SSR吗？你是怎么做的？","slug":"ssr解决了什么问题-有做过ssr吗-你是怎么做的","link":"#ssr解决了什么问题-有做过ssr吗-你是怎么做的","children":[]},{"level":2,"title":"说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？","slug":"说下你的vue项目的目录结构-如果是大型项目你该怎么划分结构和划分组件呢","link":"#说下你的vue项目的目录结构-如果是大型项目你该怎么划分结构和划分组件呢","children":[]},{"level":2,"title":"vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？","slug":"vue要做权限管理该怎么做-如果控制到按钮级别的权限怎么做","link":"#vue要做权限管理该怎么做-如果控制到按钮级别的权限怎么做","children":[]},{"level":2,"title":"Vue项目中你是如何解决跨域的呢？","slug":"vue项目中你是如何解决跨域的呢","link":"#vue项目中你是如何解决跨域的呢","children":[]},{"level":2,"title":"vue项目本地开发完成后部署到服务器后报404是什么原因呢？","slug":"vue项目本地开发完成后部署到服务器后报404是什么原因呢","link":"#vue项目本地开发完成后部署到服务器后报404是什么原因呢","children":[]},{"level":2,"title":"你是怎么处理vue项目中的错误的？","slug":"你是怎么处理vue项目中的错误的","link":"#你是怎么处理vue项目中的错误的","children":[]},{"level":2,"title":"vue3有了解过吗？能说说跟vue2的区别吗(新特性)？","slug":"vue3有了解过吗-能说说跟vue2的区别吗-新特性","link":"#vue3有了解过吗-能说说跟vue2的区别吗-新特性","children":[]},{"level":2,"title":"选项式API与组合式API","slug":"选项式api与组合式api","link":"#选项式api与组合式api","children":[]},{"level":2,"title":"ref和reactive","slug":"ref和reactive","link":"#ref和reactive","children":[]},{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[]},{"level":2,"title":"watch和computed","slug":"watch和computed","link":"#watch和computed","children":[]},{"level":2,"title":"组件通信","slug":"组件通信","link":"#组件通信","children":[]},{"level":2,"title":"路由","slug":"路由","link":"#路由","children":[]},{"level":2,"title":"快速上手Vuex 到 手写简易 Vuex","slug":"快速上手vuex-到-手写简易-vuex","link":"#快速上手vuex-到-手写简易-vuex","children":[]},{"level":2,"title":"Vue性能优化","slug":"vue性能优化","link":"#vue性能优化","children":[]},{"level":2,"title":"Vue 从template到render发生了什么？","slug":"vue-从template到render发生了什么","link":"#vue-从template到render发生了什么","children":[]},{"level":2,"title":"v-model原理","slug":"v-model原理","link":"#v-model原理","children":[]}],"git":{"updatedTime":1738722167000,"contributors":[{"name":"LiHegui","username":"LiHegui","email":"1487647822@qq.com","commits":1,"url":"https://github.com/LiHegui"}]},"filePathRelative":"interview/Vue/vue.md"}');export{c as comp,r as data};
